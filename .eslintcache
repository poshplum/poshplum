[{"/home/san/dev/poshplum-next/.eslintrc.cjs":"1","/home/san/dev/poshplum-next/packages/poshplum/rollup.config.js":"2","/home/san/dev/poshplum-next/packages/poshplum/src/Layout.js":"3","/home/san/dev/poshplum-next/packages/poshplum/src/MD.tsx":"4","/home/san/dev/poshplum-next/packages/poshplum/src/actors/KeyActor.js":"5","/home/san/dev/poshplum-next/packages/poshplum/src/actors/NotificationArea.js":"6","/home/san/dev/poshplum-next/packages/poshplum/src/actors/PortalRegistry.js":"7","/home/san/dev/poshplum-next/packages/poshplum/src/components/Chip.js":"8","/home/san/dev/poshplum-next/packages/poshplum/src/components/ErrorTrigger.js":"9","/home/san/dev/poshplum-next/packages/poshplum/src/components/FormSection.js":"10","/home/san/dev/poshplum-next/packages/poshplum/src/components/Notification.js":"11","/home/san/dev/poshplum-next/packages/poshplum/src/components/SectionTitle.js":"12","/home/san/dev/poshplum-next/packages/poshplum/src/docs.tsx":"13","/home/san/dev/poshplum-next/packages/poshplum/src/helpers/ClassNames.js":"14","/home/san/dev/poshplum-next/packages/poshplum/src/helpers/isOutsideDOM.js":"15","/home/san/dev/poshplum-next/packages/poshplum/src/helpers/matchChildType.js":"16","/home/san/dev/poshplum-next/packages/poshplum/src/helpers/mousetrap.js":"17","/home/san/dev/poshplum-next/packages/poshplum/src/index.ts":"18","/home/san/dev/poshplum-next/packages/poshplum/src/main.tsx":"19","/home/san/dev/poshplum-next/packages/poshplum/src/reactor/index.ts":"20","/home/san/dev/poshplum-next/packages/poshplum/src/vite-env.d.ts":"21","/home/san/dev/poshplum-next/packages/poshplum/vite.config.ts":"22","/home/san/dev/poshplum-next/packages/utils/platform/browser/SubtleCrypto.js":"23","/home/san/dev/poshplum-next/packages/utils/platform/browser/TextEncoder.js":"24","/home/san/dev/poshplum-next/packages/utils/platform/browser/child_process.js":"25","/home/san/dev/poshplum-next/packages/utils/platform/browser/logDestination.js":"26","/home/san/dev/poshplum-next/packages/utils/platform/browser/os.js":"27","/home/san/dev/poshplum-next/packages/utils/platform/browser/stdout.js":"28","/home/san/dev/poshplum-next/packages/utils/platform/server/SubtleCrypto.js":"29","/home/san/dev/poshplum-next/packages/utils/platform/server/TextEncoder.js":"30","/home/san/dev/poshplum-next/packages/utils/platform/server/child_process.js":"31","/home/san/dev/poshplum-next/packages/utils/platform/server/logDestination.js":"32","/home/san/dev/poshplum-next/packages/utils/platform/server/os.js":"33","/home/san/dev/poshplum-next/packages/utils/platform/server/stdout.js":"34","/home/san/dev/poshplum-next/packages/utils/rollup.browser.config.js":"35","/home/san/dev/poshplum-next/packages/utils/rollup.config.js":"36","/home/san/dev/poshplum-next/packages/utils/src/CryptoHelper.js":"37","/home/san/dev/poshplum-next/packages/utils/src/StateMachine.js":"38","/home/san/dev/poshplum-next/packages/utils/src/StateMachineNext.ts":"39","/home/san/dev/poshplum-next/packages/utils/src/asyncDelay.js":"40","/home/san/dev/poshplum-next/packages/utils/src/asyncSingletonMethod.js":"41","/home/san/dev/poshplum-next/packages/utils/src/emailRegex.js":"42","/home/san/dev/poshplum-next/packages/utils/src/ensureProtoChainProp.js":"43","/home/san/dev/poshplum-next/packages/utils/src/hasError.js":"44","/home/san/dev/poshplum-next/packages/utils/src/index-browser.ts":"45","/home/san/dev/poshplum-next/packages/utils/src/index.ts":"46","/home/san/dev/poshplum-next/packages/utils/src/misc.js":"47","/home/san/dev/poshplum-next/packages/utils/src/timeAgo.js":"48","/home/san/dev/poshplum-next/packages/utils/src/zonedLogger.js":"49"},{"size":5320,"mtime":1678310495605,"results":"50","hashOfConfig":"51"},{"size":3535,"mtime":1675645256519,"results":"52","hashOfConfig":"51"},{"size":14002,"mtime":1678310763447,"results":"53","hashOfConfig":"51"},{"size":395,"mtime":1672959739254,"results":"54","hashOfConfig":"51"},{"size":18948,"mtime":1674844330529,"results":"55","hashOfConfig":"51"},{"size":4963,"mtime":1676398444616,"results":"56","hashOfConfig":"51"},{"size":1413,"mtime":1676398367056,"results":"57","hashOfConfig":"51"},{"size":2879,"mtime":1674153808488,"results":"58","hashOfConfig":"51"},{"size":808,"mtime":1672620447030,"results":"59","hashOfConfig":"51"},{"size":1073,"mtime":1675006975744,"results":"60","hashOfConfig":"51"},{"size":1076,"mtime":1672620423974,"results":"61","hashOfConfig":"51"},{"size":2607,"mtime":1675007000192,"results":"62","hashOfConfig":"51"},{"size":787,"mtime":1672959621288,"results":"63","hashOfConfig":"51"},{"size":550,"mtime":1676398355220,"results":"64","hashOfConfig":"51"},{"size":416,"mtime":1672959697365,"results":"65","hashOfConfig":"51"},{"size":664,"mtime":1676398444616,"results":"66","hashOfConfig":"51"},{"size":30758,"mtime":1672959708369,"results":"67","hashOfConfig":"51"},{"size":1831,"mtime":1678308545799,"results":"68","hashOfConfig":"51"},{"size":152,"mtime":1672959739818,"results":"69","hashOfConfig":"51"},{"size":170,"mtime":1676398283819,"results":"70","hashOfConfig":"51"},{"size":38,"mtime":1672509378387,"results":"71","hashOfConfig":"51"},{"size":1085,"mtime":1672959622648,"results":"72","hashOfConfig":"51"},{"size":67,"mtime":1673113997465,"results":"73","hashOfConfig":"51"},{"size":48,"mtime":1673830766862,"results":"74","hashOfConfig":"51"},{"size":34,"mtime":1673126856922,"results":"75","hashOfConfig":"51"},{"size":260,"mtime":1673115237732,"results":"76","hashOfConfig":"51"},{"size":24,"mtime":1673115392360,"results":"77","hashOfConfig":"51"},{"size":29,"mtime":1673025264326,"results":"78","hashOfConfig":"51"},{"size":82,"mtime":1676592408741,"results":"79","hashOfConfig":"51"},{"size":286,"mtime":1676592526550,"results":"80","hashOfConfig":"51"},{"size":49,"mtime":1676591104671,"results":"81","hashOfConfig":"51"},{"size":1930,"mtime":1676593245871,"results":"82","hashOfConfig":"51"},{"size":26,"mtime":1676591104671,"results":"83","hashOfConfig":"51"},{"size":459,"mtime":1676592224419,"results":"84","hashOfConfig":"51"},{"size":2427,"mtime":1674511124239,"results":"85","hashOfConfig":"51"},{"size":1743,"mtime":1673994662955,"results":"86","hashOfConfig":"51"},{"size":5256,"mtime":1673396109093,"results":"87","hashOfConfig":"51"},{"size":32020,"mtime":1677435418022,"results":"88","hashOfConfig":"51"},{"size":34718,"mtime":1676588989357,"results":"89","hashOfConfig":"51"},{"size":158,"mtime":1672959915397,"results":"90","hashOfConfig":"51"},{"size":3898,"mtime":1672959872866,"results":"91","hashOfConfig":"51"},{"size":217,"mtime":1672959871206,"results":"92","hashOfConfig":"51"},{"size":1740,"mtime":1672959884057,"results":"93","hashOfConfig":"51"},{"size":1868,"mtime":1672959916981,"results":"94","hashOfConfig":"51"},{"size":1063,"mtime":1678307855138,"results":"95","hashOfConfig":"51"},{"size":996,"mtime":1678307855142,"results":"96","hashOfConfig":"51"},{"size":4518,"mtime":1674859581231,"results":"97","hashOfConfig":"51"},{"size":3878,"mtime":1672959919249,"results":"98","hashOfConfig":"51"},{"size":48500,"mtime":1678306719739,"results":"99","hashOfConfig":"51"},{"filePath":"100","messages":"101","suppressedMessages":"102","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"uahp9q",{"filePath":"103","messages":"104","suppressedMessages":"105","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"106"},{"filePath":"107","messages":"108","suppressedMessages":"109","errorCount":5,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":1,"fixableWarningCount":13,"source":"110"},{"filePath":"111","messages":"112","suppressedMessages":"113","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"114","messages":"115","suppressedMessages":"116","errorCount":16,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":1,"fixableWarningCount":5,"source":"117"},{"filePath":"118","messages":"119","suppressedMessages":"120","errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":1,"fixableWarningCount":3,"source":"121"},{"filePath":"122","messages":"123","suppressedMessages":"124","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"125","messages":"126","suppressedMessages":"127","errorCount":1,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":11,"source":"128"},{"filePath":"129","messages":"130","suppressedMessages":"131","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"132"},{"filePath":"133","messages":"134","suppressedMessages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"136","messages":"137","suppressedMessages":"138","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"139"},{"filePath":"140","messages":"141","suppressedMessages":"142","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"143","messages":"144","suppressedMessages":"145","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"146","messages":"147","suppressedMessages":"148","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"149","messages":"150","suppressedMessages":"151","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"152","messages":"153","suppressedMessages":"154","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"155","messages":"156","suppressedMessages":"157","errorCount":15,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"158","messages":"159","suppressedMessages":"160","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"161","messages":"162","suppressedMessages":"163","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"164","messages":"165","suppressedMessages":"166","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"167","messages":"168","suppressedMessages":"169","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"170","messages":"171","suppressedMessages":"172","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"173","messages":"174","suppressedMessages":"175","errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"176"},{"filePath":"177","messages":"178","suppressedMessages":"179","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"180","messages":"181","suppressedMessages":"182","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"183","messages":"184","suppressedMessages":"185","errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"186","messages":"187","suppressedMessages":"188","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"189","messages":"190","suppressedMessages":"191","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"192","messages":"193","suppressedMessages":"194","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"195"},{"filePath":"196","messages":"197","suppressedMessages":"198","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"199","messages":"200","suppressedMessages":"201","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"202","messages":"203","suppressedMessages":"204","errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"205"},{"filePath":"206","messages":"207","suppressedMessages":"208","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"209","messages":"210","suppressedMessages":"211","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"212","messages":"213","suppressedMessages":"214","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"215"},{"filePath":"216","messages":"217","suppressedMessages":"218","errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"219","messages":"220","suppressedMessages":"221","errorCount":3,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":14,"source":"222"},{"filePath":"223","messages":"224","suppressedMessages":"225","errorCount":11,"fatalErrorCount":0,"warningCount":37,"fixableErrorCount":1,"fixableWarningCount":28,"source":"226"},{"filePath":"227","messages":"228","suppressedMessages":"229","errorCount":23,"fatalErrorCount":0,"warningCount":37,"fixableErrorCount":1,"fixableWarningCount":28,"source":"230"},{"filePath":"231","messages":"232","suppressedMessages":"233","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"234","messages":"235","suppressedMessages":"236","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"237"},{"filePath":"238","messages":"239","suppressedMessages":"240","errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":8,"fixableWarningCount":0,"source":"241"},{"filePath":"242","messages":"243","suppressedMessages":"244","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"245","messages":"246","suppressedMessages":"247","errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"248"},{"filePath":"249","messages":"250","suppressedMessages":"251","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"252","messages":"253","suppressedMessages":"254","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"255","messages":"256","suppressedMessages":"257","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":"258"},{"filePath":"259","messages":"260","suppressedMessages":"261","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"262","messages":"263","suppressedMessages":"264","errorCount":25,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":17,"source":"265"},"/home/san/dev/poshplum-next/.eslintrc.cjs",[],[],"/home/san/dev/poshplum-next/packages/poshplum/rollup.config.js",["266","267","268"],[],"import dts from \"rollup-plugin-dts\";\nimport typescript from \"rollup-plugin-ts\";\nimport externals from \"rollup-plugin-node-externals\";\nimport resolve from \"@rollup/plugin-node-resolve\";\n\nconst sass = require(\"sass\");\nimport postcss from \"rollup-plugin-postcss\";\n\nconst name = require(\"./package.json\").main.replace(/\\.js$/, \"\");\n\nconst bundledModules = [];\nconst forcedExternals = [];\n\nconst watchDeps = {\n    name: \"dev-deps\",\n    async buildStart() {\n        this.addWatchFile(\"./rollup.config.js\");\n    }\n}\n\nconst bundle = (config) => ({\n    ...config,\n    input: \"src/index.ts\",\n    external: (id) => {\n        if (bundledModules.includes(id)) return false;\n        if (forcedExternals.includes(id)) return true;\n        // console.warn(\"---ext detect ---\", id)\n\n        return !/^[./]/.test(id);\n    },\n});\n\nconst cssOpts = {\n    extract: true,\n    preprocessor: (content, id) =>\n        new Promise((resolve, reject) => {\n            // const result = sass.renderSync({ file: id });\n            const result = sass.compile({ file: id });\n            resolve({ code: result.css.toString() });\n        }),\n    sourceMap: true,\n\n    extensions: [\".scss\", \".css\"],\n    // extract: \"plum.css\",\n};\n\nexport default [\n    {\n        input: \"src/scss/app.scss\",\n        plugins: [postcss(cssOpts)],\n        output: { file: \"dist/plum.css\" },\n    },\n    // {\n    //     input: \"src/scss/plum.scss\",\n    //     plugins: [postcss(cssOpts)],\n    //     output: {file: \"dist/plum.css\"},\n    // },\n    bundle({\n        plugins: [\n            watchDeps,\n            externals(),\n            resolve({ browser: true }),\n            typescript({\n                transpiler: {\n                    typescriptSyntax: \"typescript\",\n                    otherSyntax: \"typescript\", // \"swc\",\n                },\n                tsconfig(existing) {\n                    // console.warn(existing)\n                    return existing\n                },\n                swcConfig: {\n                    \"jsc\": {\n                        \"parser\": {\n                          \"syntax\": \"ecmascript\",\n                          \"jsx\": false,\n                          \"dynamicImport\": false,\n                          \"privateMethod\": false,\n                          \"functionBind\": false,\n                          \"exportDefaultFrom\": false,\n                          \"exportNamespaceFrom\": false,\n                          \"decorators\": true,\n                          \"decoratorsBeforeExport\": true,\n                          \"topLevelAwait\": false,\n                          \"importMeta\": false,\n                          \"preserveAllComments\": false\n                        },\n                        \"transform\": null,\n                        \"target\": \"es5\",\n                        \"loose\": false,\n                        \"externalHelpers\": false,\n                        // Requires v1.2.50 or upper and requires target to be es2016 or upper.\n                        \"keepClassNames\": true\n                      },\n                      \"isModule\": false                                    },\n            }),\n        ],\n        output: [\n            {\n                file: `${name}.js`,\n                format: \"cjs\",\n                sourcemap: true,\n            },\n            {\n                file: `${name}.mjs`,\n                format: \"es\",\n                sourcemap: true,\n            },\n        ],\n    }),\n    bundle({\n        plugins: [dts()],\n        output: {\n            file: `${name}.d.ts`,\n            format: \"es\",\n        },\n    }),\n];\n","/home/san/dev/poshplum-next/packages/poshplum/src/Layout.js",["269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288"],["289","290","291","292","293","294","295"],"import React, { Component } from \"react\";\nimport flatten from \"lodash/flatten\";\nimport groupBy from \"lodash/groupBy\";\nimport mapValues from \"lodash/mapValues\";\nimport map from \"lodash/map\";\nimport find from \"lodash/find\";\nimport { Reactor } from \"./Reactor\";\nimport { autobind } from \"@poshplum/utils/browser\";\nimport { ErrorTrigger } from \"./components/ErrorTrigger\";\n\nconst invalidGenericTagUsage = Symbol(\"invalidGenericTagUsage\");\nexport const asPropIsRequired = Symbol(\"as= prop is required!\");\nconst hot = import.meta.hot;\nexport class Layout extends Component {\n    static asPropIsRequired = asPropIsRequired\n\n    static defaultSlot(name) {\n        let slot = this.namedSlot(name);\n        slot.withTagName = (name) => {\n            slot.tagName = name;\n            return slot;\n        };\n        slot.multiple = () => {\n            slot.isMultiple = true;\n            return slot;\n        };\n\n        slot.isDefault = true;\n        return slot;\n    }\n    static _asGenericTag(basedOnSlot, tagTmpl={\n        [invalidGenericTagUsage]: true\n    }) {\n        const { ...tagTemplate } = (asPropIsRequired === tagTmpl ? {\n            as : asPropIsRequired,\n        } : tagTmpl);\n        //! transforms the tag template into a tiny function component that uses the tag template\n        //  as default props.\n\n        if(tagTemplate[invalidGenericTagUsage]) throw new Error(`asGenericTag() should be called on the result of defaultSlot(slotName) or namedSlot(slotName)`)\n        if (tagTemplate.className)\n            throw new Error(\n                `asGenericTag: invalid generic \\`className=\\` tag template.  Set overrideClassName to provide a default className that can be overridden.  The generated component will honor additional className= attributes when you use <YourLayoutSlot className=... />`\n            );\n            \n            \n            return basedOnSlot.withTagName(tagTemplate.as).withMarkup(({\n                as: As = tagTemplate.as,\n                overrideClassName = tagTemplate.overrideClassName,\n                className,\n                children,\n                ...props\n            }) => {\n                if( asPropIsRequired === As ) {\n                    const msg = `missing required as= prop for ${basedOnSlot.displayName}`;\n                    return <ErrorTrigger error={msg}>\n                        Developer error: {msg}\n                    </ErrorTrigger>\n                }\n            return <As className={`${overrideClassName} ${className}`} {...props}>\n                {children}\n            </As>;\n        });\n    }\n    static withMarkup(basedOnSlot, RenderComponent) {\n        let componentWithMarkup;\n        let slot = (componentWithMarkup = ({ children, ...props }) => (\n            <RenderComponent {...props}>{children}</RenderComponent>\n        ));\n        slot.raw = RenderComponent;\n        slot.displayName = basedOnSlot.displayName;\n\n        // if (basedOnSlot.tagName) throw new Error(`slot: withTagName(\"${basedOnSlot.tagName}\"): .withMarkup(...) conflicts with bare tag name.`)\n        if (basedOnSlot.isMultiple) slot.isMultiple = basedOnSlot.isMultiple;\n        if (basedOnSlot.isDefault) slot.isDefault = basedOnSlot.isDefault;\n        if (!RenderComponent.displayName)\n            RenderComponent.displayName = `slot‹${basedOnSlot.displayName}›`;\n        if (slot.tagName) componentWithMarkup.tagName = slot.tagName;\n\n        slot.withTagName = (tn) => {\n            throw new Error(\n                `slot: withMarkup(...): withTagName(\"${tn}\") primitive conflicts with markup-based slot - try withTagName().withMarkup() instead?`\n            );\n        };\n\n        slot.multiple = () => {\n            slot.isMultiple = true;\n            return slot;\n        };\n        return slot;\n    }\n    static namedSlot(name) {\n        let slot = ({ children }) => [children];\n        slot.withTagName = (name) => {\n            slot.tagName = name;\n            return slot;\n        };\n        slot.multiple = () => {\n            slot.isMultiple = true;\n            return slot;\n        };\n\n        slot.displayName = name;\n        slot.isPlain = true;\n\n        slot.withMarkup = (RenderComponent) =>\n            this.withMarkup(slot, RenderComponent);\n        slot.withMarkup.displayName = name;\n        slot.asGenericTag = (genericTemplate) =>\n            this._asGenericTag(slot, genericTemplate);\n\n        return slot;\n    }\n\n    // returns the list of slots configured for the layout.\n    static getSlots() {\n        if (!this.slots)\n            throw new Error(\n                `Layout ${this.constructor.name}: static slots not defined`\n            );\n        return this.slots;\n    }\n\n    get debug() {\n        return this.props.debug;\n    }\n\n    // used for extracting children matching the slots defined in the layout.\n    // returns a ready-to-use map of slot-names to rendered content.\n    get slots() {\n        let slots = this.constructor.getSlots();\n        let slotToSlotNames;\n        if (this.constructor.hasOwnProperty(\"_slotsVerified\")) {\n            slotToSlotNames = this.constructor._slotsVerified;\n        } else {\n            slotToSlotNames = new Map();\n            map(slots, (slot, k) => {\n                let slotName =\n                    slot.slotName ||\n                    slot.constructor.wrappedName ||\n                    slot.displayName ||\n                    slot.constructor.displayName ||\n                    slot.name ||\n                    slot.constructor.name;\n                // console.log(\"slot: \", k, slotName, slot );\n                let foundSlot = this.constructor[slotName];\n                if (!foundSlot || foundSlot !== slot) {\n                    console.warn(\n                        `Layout: ${this.constructor.name}: slot '${slotName}' is not declared as a static member.  Add it to the class definition to get better autocomplete.  \\n  ^ This can also result in inscrutable \"React.createElement: type is invalid\" errors.`\n                    );\n                }\n                slotToSlotNames.set(slot, slotName);\n            });\n            this.constructor._slotsVerified = slotToSlotNames;\n        }\n        let { children = [] } = this.props;\n        if (!Array.isArray(children)) {\n            children = [children];\n        }\n        children = flatten(children);\n\n        let defaultSlot = find(slots, (slotType) => slotType.isDefault);\n        let defaultSlotName =\n            defaultSlot && (defaultSlot.displayName || defaultSlot.name);\n\n        // locate the instances of children provided\n        let content = groupBy(children, (child) => {\n            if (!child) return undefined;\n\n            if (this.debug)\n                console.log(\n                    \"child:\",\n                    child,\n                    child.type,\n                    child.type && child.type.displayName\n                );\n\n            let foundName =\n                slotToSlotNames.get(child.type) ||\n                find(Object.keys(slots), (key) => {\n                    // console.log(child, child.type, \" <-> \", slotType.displayName, slotType.isDefault, slotType );\n\n                    const slotType = slots[key];\n                    const slotName = slotToSlotNames.get(slotType);\n                    if (!slotName) {\n                        // eslint-disable-next-line no-debugger\n                        debugger;\n                        throw new Error(\n                            `‹impossible?› iterated slot doesn't have a name`\n                        );\n                    }\n                    // eslint-disable-next-line no-debugger\n                    if (child.props && child.props.debug) debugger;\n                    // eslint-disable-next-line no-debugger\n                    if (slotType.debug) debugger;\n\n                    if (hot) {\n                        let childName =\n                            (child.type &&\n                                // child.type.slotName ||\n                                (child.type.wrappedName ||\n                                    child.type.displayName)) ||\n                            child.type;\n\n                        //  ✓ works with react webpack hot loader\n                        if (slotName === childName) return true;\n                    }\n                    if (slotType.tagName && slotType.tagName === child.type) {\n                        return true;\n                    }\n                    if (slotType.isPrototypeOf(child.type)) return true;\n                    return slotType === child.type;\n                });\n            let foundSlot = foundName && slots[foundName];\n            let foundDisplayName = foundSlot && slotToSlotNames.get(foundSlot);\n\n            if (!foundSlot) {\n                // console.log(\"slot: default\", foundSlot, child)\n                foundName = \"default\";\n                // eslint-disable-next-line no-debugger\n                if (this.debug > 1) debugger;\n            } else {\n                if (foundDisplayName !== foundName) {\n                    console.warn(\n                        `slot '${foundName}' has component with displayName/name = ${foundDisplayName}`\n                    );\n                }\n            }\n\n            if (!foundName)\n                throw new Error(\n                    \"every layout slot needs a 'displayName' or 'name'\"\n                );\n            return foundName;\n        });\n        if (content.default) {\n            // console.warn(`Some children didn't match any slots... -> default`, content.default);\n            if (!defaultSlot) {\n                console.error(\n                    \"default content without default slot\",\n                    content.default\n                );\n                throw new Error(\n                    `${this.constructor.displayName}: default content was found, with no defaultSlot to hold it.`\n                );\n            }\n\n            content[defaultSlotName] = React.createElement(defaultSlot, {\n                children: content.default,\n            });\n            delete content.default;\n        }\n        if (this.debug) console.log({ children, content });\n        content = mapValues(content, (foundContents, key) => {\n            if (\"undefined\" === key) return null;\n\n            let foundSlot = slots[key];\n            if (foundSlot && foundSlot.isMultiple) {\n                // console.log(\"returning multiple items in slot\", key, foundContents);\n                // debugger\n                return foundContents;\n            }\n\n            if (!foundSlot) {\n                console.warn(\"no slot type found:\", {\n                    key,\n                    foundSlot,\n                    foundContents,\n                });\n                return null;\n            }\n\n            // debugger\n            if (foundContents.length > 1) {\n                let hasFallback, foundOverride;\n                let matchingChildren = map(foundContents, (item) => {\n                    const { children, fallback } = item.props;\n                    if (fallback) {\n                        hasFallback = item;\n                    } else foundOverride = item;\n\n                    // coalesces slots having multiple instances to be a single instance with multiple children\n                    if (item.type === foundSlot) return children;\n\n                    if (hot) {\n                        let childName =\n                            (item.type && item.type.displayName) || item.type;\n                        if (foundSlot.displayName === childName) {\n                            //  ✓ works with react webpack hot loader\n                            return item.props.children;\n                        }\n                    }\n                    return item;\n                });\n                if (hasFallback && foundOverride) {\n                    //! it ignores fallback slot content when an overriding slot was provided\n                    // eslint-disable-next-line no-debugger\n                    if (hasFallback?.props?.debug) debugger;\n                    // eslint-disable-next-line no-debugger\n                    if ( foundOverride?.props?.debug ) debugger;\n\n                    matchingChildren = foundOverride;\n                    if (foundSlot.tagName) return matchingChildren;\n                    matchingChildren = foundOverride.props.children;\n                    //! XXX if an overriding slot was provided as empty, it behaves as if neither the override, nor the fallback content, was provided at all.\n                    //! if an overriding slot was provided as `override omit`, it behaves as if neither the override, nor the fallback content, was provided at all.\n                    if (foundOverride.props.omit) return null;\n                    if (foundOverride.props.override) return foundOverride;\n                    if (\n                        !matchingChildren ||\n                        (matchingChildren && 0 === matchingChildren.length)\n                    ) {\n                        const t = this;\n                        console.warn(\n                            t,\n                            `overridden slot ${\n                                foundSlot.displayName || \"‹unknown name›\"\n                            } with no child elements should use boolean 'override' or 'omit' property (see debugger)`\n                        );\n                        // eslint-disable-next-line no-debugger\n                        debugger;\n                    }\n                }\n                if (foundOverride.type == foundSlot) return foundOverride;\n                if (foundSlot.tagName) return matchingChildren;\n                return React.createElement(foundSlot, {\n                    children: matchingChildren,\n                });\n            }\n            if (foundContents.length == 1) return foundContents[0];\n            return foundContents;\n        });\n\n        if (this.debug) console.log(\"after value-mapping:\", content);\n        return content;\n    }\n}\nLayout.withMarkup = Layout.withMarkup.bind(Layout);\n","/home/san/dev/poshplum-next/packages/poshplum/src/MD.tsx",["296","297"],[],"/home/san/dev/poshplum-next/packages/poshplum/src/actors/KeyActor.js",["298","299","300","301","302","303","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","320","321","322","323"],[],"import React from \"react\";\nimport { Reactor } from \"../Reactor\";\nimport { Action } from \"../reactor/Action\";\nimport { Mousetrap } from \"../helpers/mousetrap\";\nimport { isInsideDOM, isOutsideDOM } from \"../helpers/isOutsideDOM\";\nimport { Actor } from \"../reactor/Actor\";\nimport { autobind } from \"@poshplum/utils/browser\";\n\nconst isMac = !!window.navigator.platform.match(/^Mac/);\nfunction button(s) {\n    return <span className=\"chip bg-gray\">{s}</span>;\n}\n\nconst modRegexp = /mod\\+/gi;\nconst modString = isMac ? \"⌘+\" : \"ctrl+\";\nconst commandRegexp = /(.*)command\\+(.*)/gi;\nconst commandString = isMac ? \"$1⌘+$2\" : \"\";\nconst shiftRegexp = /shift\\+?/gi;\nconst shiftString = \"⇧\";\nconst ctrlRegexp = /ctrl\\+?/gi;\nconst ctrlString = \"‹ctrl›\";\nconst altRegexp = /alt\\+?/gi;\nconst altString = \"‹alt›\";\n\nMousetrap.stopCallback = () => {};\n\n@Actor\nexport class KeyActor extends React.Component {\n    static logFacility = \"keyActor\";\n\n    constructor(props) {\n        super(props);\n        this.bindings = new Map();\n        this.state = {\n            gen: 0,\n            helpPanel: false,\n        };\n    }\n    name() {\n        return \"keys\";\n    }\n\n    registerKeyHandler = Reactor.bindWithBreadcrumb(\n        this.registerKeyHandler,\n        this\n    );\n    removeKeyHandler = Reactor.bindWithBreadcrumb(this.removeKeyHandler, this);\n    updateOnFocusChange = Reactor.bindWithBreadcrumb(\n        this.updateOnFocusChange,\n        this\n    );\n    findFocusedShortcuts = Reactor.bindWithBreadcrumb(\n        this.findFocusedShortcuts,\n        this\n    );\n\n    shortcutToString(s) {\n        return JSON.stringify(s);\n    }\n    componentDidMount() {\n        // console.warn(\"-> didMount\")\n        // console.warn(\"hi\");\n        // console.warn(\"hi2\")\n        let { target: targetNode } = this.props;\n        // console.warn(\"hi\")\n        if (!targetNode) {\n            if (this.props.debug) console.warn(\"probing for reactor node\");\n            let probeEvent = Reactor.ReactorProbe({\n                single: true,\n                // attach to the first found reactor\n                onReactor(reactor) {\n                    if (targetNode) {\n                        throw new Error(\"this shouldn't happen\");\n                    }\n                    targetNode = reactor.el;\n                    return reactor;\n                },\n            });\n            this.trigger(probeEvent);\n            if (!targetNode)\n                this.trigger(\n                    Reactor.ErrorEvent({\n                        error: \"no reactor found for binding keys\",\n                    })\n                );\n        }\n        // console.warn(\"attaching mousetrap to\", targetNode.outerHTML)\n        this.mousetrap = new Mousetrap(targetNode);\n        // console.warn(\"<- didMount\")\n\n        this.registerHelpKeys();\n    }\n    componentWillUnmount() {\n        this.mousetrap?.destroy();\n    }\n    updateOnFocusChange(e) {\n        if (this._unmounting) return;\n        if (!this._focusUpdating) {\n            requestAnimationFrame(this.findFocusedShortcuts);\n            this._focusUpdating = true;\n        }\n    }\n    findFocusedShortcuts() {\n        const element = document.activeElement;\n        this._focusUpdating = false;\n        for (const [shortcutString, binding] of this.bindings) {\n            let { handlers, current, focused } = binding;\n            let preferred,\n                pDepth = 99999;\n\n            for (const [handler, details] of handlers) {\n                if (!details.at) continue;\n\n                const depth = isInsideDOM(element, details.at);\n                if (depth && depth < pDepth) {\n                    pDepth = depth;\n                    preferred = handler;\n                }\n            }\n            if (!preferred && binding.focused) binding.focused = null;\n            if (preferred) binding.focused = handlers.get(preferred);\n        }\n        this.bump();\n    }\n    registerKeyHandler({\n        detail: {\n            debug = this.props.debug,\n            inFormFields = true,\n            desc,\n            hidden,\n            shortcut,\n            at,\n            trigger,\n            handler,\n            on,\n            preventDefault,\n        },\n    }) {\n        if (debug) {\n            const triggerDescription = `->${trigger && \" triggers action\"} ${\n                trigger || handler.name\n            }`;\n            console.warn(\n                `registering keyHandler(${shortcut}) ${triggerDescription} (on ${\n                    on || \"automatic\"\n                } event-type)`\n            );\n        }\n        if (debug > 1) console.warn(this);\n\n        const shortcutString = this.shortcutToString(shortcut);\n        let thisKeyBinding = this.bindings.get(shortcutString);\n        if (thisKeyBinding) {\n            if (on !== thisKeyBinding.on) {\n                throw new Error(\n                    `event-type mismatch: ${shortcut} ${on} -> ${triggerDescription}, vs existing event on ${thisKeyBinding.on}`\n                );\n            }\n        } else {\n            const registeredHandlers = new Map();\n            const priorities = new Map();\n            const mousetrap = this.mousetrap;\n            const outerDebug = debug;\n            thisKeyBinding = {\n                on,\n                shortcutOrig: shortcut,\n                hidden,\n                handleShortcut: (event) => {\n                    const debug = outerDebug ||\n                        Math.max(\n                            0,\n                            ...[...thisKeyBinding.handlers.values()]\n                                .map((x) => x.debug)\n                                .filter((d) => !!d)\n                        );\n                    this.logger.consoleInfo(`finding handler: ${shortcut}`);\n                    if (debug > 1) debugger;\n                    if (!thisKeyBinding.current && !thisKeyBinding.focused)\n                        return;\n                    const element = event.target;\n                    const selectedHandler =\n                        thisKeyBinding.focused || thisKeyBinding.current;\n                    if (!selectedHandler.handler) debugger;\n                    if (\n                        !selectedHandler.inFormFields &&\n                        (element.tagName == \"INPUT\" ||\n                            element.tagName == \"SELECT\" ||\n                            element.tagName == \"TEXTAREA\" ||\n                            element.isContentEditable)\n                    )\n                        return true;\n                    if (selectedHandler) {\n                        this.logger.consoleInfo(`finding handler: ${shortcut}`);\n                        if (debug > 1) debugger;\n                        try {\n                            selectedHandler.handler(event);\n                        } catch (e) {\n                            const errorTarget =\n                                selectedHandler.at || this._reactor.el;\n                            const description =\n                                selectedHandler.description ||\n                                selectedHandler.handler.name;\n                            this.logger.error(\n                                {\n                                    detail: {\n                                        shortcut,\n                                        description,\n                                        error: e.message || e.stack || e,\n                                    },\n                                },\n                                `Error in key handler`\n                            );\n\n                            Reactor.trigger(errorTarget, \"error\", {\n                                single: true,\n                                error:\n                                    `Error in keyboard handler ${description}: ` +\n                                    (e.message || e.stack || JSON.stringify(e)),\n                            });\n                        }\n                        if (selectedHandler.preventDefault)\n                            event.preventDefault();\n                    } else {\n                        this.logger.consoleInfo(`finding handler: ${shortcut}`);\n                    }\n                },\n                priorities,\n                current: null,\n                handlers: registeredHandlers,\n                remove: (handler) => {\n                    const {\n                        desc,\n                        trigger,\n                        handler: innerHandler,\n                    } = (handler.boundThis && handler.boundThis.props) || {};\n                    const handlerInfo = {\n                        desc,\n                        hidden,\n                        trigger,\n                        name: handler.name,\n                        innerHandler: innerHandler && innerHandler.name,\n                    };\n                    if (!registeredHandlers.has(handler)) {\n                        debugger;\n                        throw new Error(\n                            `Keyboard handler: remove(handler): not found ${handler.name}`\n                        );\n                    } else {\n                        this.logger.info(\n                            { detail: handlerInfo },\n                            \"removing keyboard shortcut handler\"\n                        );\n                    }\n                    priorities.delete(handler);\n                    registeredHandlers.delete(handler);\n                    if (registeredHandlers.size) {\n                        // if this isn't the currently-active handler, silent removal\n                        // (already done above) is OK.\n                        if (thisKeyBinding.current.handler == handler) {\n                            // But if it's the current handler, we should figure out\n                            // the correct replacement:\n                            //   * the last stacking handler\n                            let lastStacking;\n                            for (const [\n                                handler,\n                                priority,\n                            ] of priorities.entries()) {\n                                lastStacking = handler;\n                            }\n                            const nextHandler = lastStacking;\n                            thisKeyBinding.current =\n                                registeredHandlers.get(nextHandler);\n                            this.updateOnFocusChange();\n                        }\n                    } else {\n                        // no remaining registered handlers for this key.\n                        // unbinding the key does prevent mousetrap from rebinding it later,\n                        //   so we're just retaining the binding, but without keeping any current handler.\n                        //   mousetrap.unbind(shortcut, on);\n                        thisKeyBinding.current = null;\n                    }\n                },\n            };\n            this.bindings.set(shortcutString, thisKeyBinding);\n            this.mousetrap.bind(shortcut, thisKeyBinding.handleShortcut, on);\n        }\n        const thisHandlerPriority = \"stacking\";\n        const thisHandlerDetail = {\n            handler,\n            at,\n            preventDefault,\n            desc,\n            hidden,\n            inFormFields,\n            priority: thisHandlerPriority,\n        };\n        thisKeyBinding.priorities.set(handler, thisHandlerPriority);\n        thisKeyBinding.handlers.set(handler, thisHandlerDetail);\n\n        const { handler: currentHandler } = thisKeyBinding.current || {};\n\n        thisKeyBinding.current = thisHandlerDetail;\n        this.updateOnFocusChange();\n    }\n    bump() {\n        this.bumping =\n            this.bumping ||\n            setTimeout(\n                () =>\n                    this.setState(({ gen }) => {\n                        this.logger.progress(\"bumping keyboard help content\");\n                        this.bumping = null;\n                        return { gen: 1 + gen };\n                    }),\n                120\n            );\n    }\n    removeKeyHandler({ detail: { shortcut, handler, on } }) {\n        this.logger.progress(\"remove key handler\", { shortcut, handler });\n        let thisKeyBinding = this.bindings.get(this.shortcutToString(shortcut));\n        thisKeyBinding.remove.call(this, handler);\n    }\n\n    helpPanel = React.createRef();\n    helpHeader = React.createRef();\n    render() {\n        const { helpPanel, onRight, showHidden } = this.state;\n\n        let itemCount = 0;\n        const rendered = (\n            <div ref={this.helpPanel}>\n                <span className=\"screader\" alia-live=\"assertive\">\n                    Keyboard Help: press Control+slash\n                </span>\n                <Action\n                    bare\n                    at={document}\n                    capture\n                    focus={this.updateOnFocusChange}\n                />\n                <Action\n                    bare\n                    at={document}\n                    capture\n                    blur={this.updateOnFocusChange}\n                />\n\n                <Action\n                    debug={0}\n                    keyboardShortcutHandler={this.registerKeyHandler}\n                />\n                <Action\n                    debug={0}\n                    removeShortcutHandler={this.removeKeyHandler}\n                />\n                <div\n                    className={`bg-dark text-light ${\n                        helpPanel ? `` : `hidden`\n                    }`}\n                    style={{\n                        position: \"fixed\",\n                        bottom: \"0vh\",\n                        borderRadius: \"4px\",\n                        opacity: \"80%\",\n                        zIndex: 42,\n                        padding: \"0.5em\",\n                        ...(onRight ? { right: 0 } : {}),\n                    }}\n                    role=\"complementary\"\n                >\n                    <h3\n                        className=\"bb-dashed\"\n                        ref={this.helpHeader}\n                        tabIndex=\"0\"\n                        aria-live=\"assertive\"\n                        aria-atomic=\"true\"\n                    >\n                        Keyboard and Controls Help\n                        <span className=\"screader\">\n                            Overlay Panel: Control+slash to close\n                        </span>\n                    </h3>\n                    <table>\n                        {[...this.bindings.entries()].map(\n                            ([shortcutString, binding]) => {\n                                const {\n                                    current,\n                                    focused,\n                                    at,\n                                    hidden,\n                                    shortcutOrig: shortcut,\n                                } = binding;\n                                if (!current) return null;\n                                const shortcuts = (\n                                    Array.isArray(shortcut)\n                                        ? shortcut.map(\n                                              (s) =>\n                                                  s &&\n                                                  this.mungeKeyboardShortcut(s)\n                                          )\n                                        : [this.mungeKeyboardShortcut(shortcut)]\n                                ).filter((x) => !!x);\n\n                                const lastShortcut = shortcuts.length - 1;\n                                const shortcutsJoined = shortcuts.flatMap(\n                                    (x, i) =>\n                                        i == lastShortcut ? (\n                                            <code>{x}</code>\n                                        ) : (\n                                            [<code>{x}</code>, \" or \"]\n                                        )\n                                );\n\n                                const { handler, desc = handler.name } =\n                                    focused || current;\n                                if (hidden && !showHidden) return null;\n                                const hiddenProps = hidden\n                                    ? { className: \"text-gray\" }\n                                    : {};\n                                itemCount++;\n                                return (\n                                    <tr>\n                                        <th>{shortcutsJoined}</th>\n                                        <td {...hiddenProps}>{desc}</td>\n                                    </tr>\n                                );\n                            }\n                        )}\n                    </table>\n                </div>\n            </div>\n        );\n        this.logger.progress(\n            `rendering keyboard help content with ${itemCount} entries`\n        );\n\n        return rendered;\n    }\n    mungeKeyboardShortcut(s) {\n        return s\n            .replace(modRegexp, modString)\n            .replace(commandRegexp, commandString)\n            .replace(ctrlRegexp, ctrlString)\n            .replace(altRegexp, altString)\n            .replace(shiftRegexp, shiftString);\n    }\n    componentDidUpdate(pProps, pState) {\n        if (this.state.helpPanel && !pState.helpPanel)\n            this.helpHeader.current.focus();\n    }\n    registerHelpKeys() {\n        this.registerKeyHandler({\n            detail: {\n                shortcut: \"ctrl+/\",\n                handler: this.toggleHelpPanel,\n                desc: \"Toggle help panel\",\n            },\n        });\n        this.registerKeyHandler({\n            detail: {\n                shortcut: \"ctrl+alt+shift+/\",\n                hidden: true,\n                handler: this.toggleHelpHidden,\n                desc: \"toggle hidden keyboard shortcuts\",\n            },\n        });\n        this.registerKeyHandler({\n            detail: {\n                shortcut: \"?\",\n                inFormFields: false,\n                handler: this.showHelpPosition,\n                desc: \"Toggle help panel / position\",\n            },\n        });\n    }\n\n    @autobind\n    toggleHelpPanel(x) {\n        x.preventDefault();\n        const showHiddenDefault = \"development\" === process.env.NODE_ENV;\n        this.setState(({ helpPanel, showHidden = showHiddenDefault }) => ({\n            helpPanel: !helpPanel,\n            showHidden,\n        }));\n    }\n\n    @autobind\n    toggleHelpHidden(x) {\n        x.preventDefault();\n        this.setState(({ showHidden }) => ({ showHidden: !showHidden }));\n    }\n\n    @autobind\n    showHelpPosition(x) {\n        x.preventDefault();\n        if (this.state.helpPanel) {\n            if (!this.state.onRight) return this.setState({ onRight: true });\n        }\n        this.setState(({ helpPanel }) => ({\n            helpPanel: !helpPanel,\n            onRight: false,\n        }));\n    }\n}\n","/home/san/dev/poshplum-next/packages/poshplum/src/actors/NotificationArea.js",["324","325","326","327","328"],[],"import React from \"react\";\nimport * as shortid from \"shortid\";\n\nimport { autobind } from \"@poshplum/utils/browser\";\nimport { Action, Subscribe, Actor } from \"../reactor/index\";\nimport { Reactor } from \"../Reactor\";\n\n@Actor\nexport class NotificationArea extends React.Component {\n    logFacility = \"notificationArea\";\n    alertsRef = React.createRef();\n    name() {\n        return \"notificationArea\"\n    }\n\n    @autobind\n    addSuccess(event) {\n        return this.addNotice(\"success\", event);\n    }\n\n    @autobind\n    addWarning(event) {\n        return this.addNotice(\"warning\", event);\n    }\n\n    @autobind\n    addError(event) {\n        return this.addNotice(\"error\", event);\n    }\n\n    @autobind\n    hold() {\n        if (this.releaser) return;\n        const holdPendingPromise = new Promise((res, rej) => {\n            this.releaser = res;\n        });\n        this.setState({\n            hold: holdPendingPromise,\n        });\n    }\n\n    @autobind\n    releaseHold(event) {\n        if (!this.state.hold) return;\n\n        const { currentTarget, relatedTarget, target } = event;\n        const stuff = { currentTarget, relatedTarget, target };\n        // console.log(stuff);\n        // console.log(\n        //     Object.entries(stuff).map(\n        //         ({ k, t }) => t === this.alertsRef.current\n        //     )\n        // );\n\n        this.releaser();\n        this.releaser = null;\n        this.setState({ hold: false });\n    }\n\n    @autobind\n    addNotice(severity, event) {\n        let { id, [severity]: notice, reactor, isDecorated } = event.detail;\n        if (!id) {\n            id = shortid.generate();\n            event.detail.id = id;\n        }\n        event.stopPropagation();\n        if (!notice) notice = JSON.stringify(event.detail);\n\n        let message = notice.message || notice;\n        const { name = \"‹NotificationArea without name=›\" } = this.props;\n\n        if (\"error\" === severity) {\n            if (isDecorated) {\n                // probably redundant, but we want to be certain that errors in particular do arrive somewhere\n                console.error(\n                    `(at ${name}):`,\n                    message + (reactor ? `\\n   ${reactor}` : \"\")\n                );\n            } else if (reactor) {\n                message = message + ` ${reactor}`;\n                console.error(`(at ${name}):`, message); // probably redundant, but we want to be certain that errors in particular do arrive somewhere\n            }\n        }\n\n        const timeout = setTimeout(async () => {\n            await this.state.hold;\n            this.setState(removeThisMessage);\n        }, 6000);\n\n        notice = { id, message, severity, timeout };\n\n        this.setState(({ notices = [] } = {}) => {\n            notices = [...notices, notice];\n            console.log(\n                `notification area ${name} -> ${notices.length} notices`,\n                notice\n            );\n            return { notices };\n        });\n\n        function removeThisMessage(state) {\n            let { notices } = state;\n            notices = notices.filter((n) => n.id !== id);\n            return { notices };\n        }\n    }\n\n    render() {\n        let { notices = [], hold = \"\" } = this.state || {};\n        let tooltip = (hold && { \"data-tooltip\": \"✋ 🖱️\" }) || {};\n\n        return (\n            <>\n                <Subscribe error={this.addError} />\n                <Subscribe success={this.addSuccess} />\n                <Subscribe warning={this.addWarning} />\n\n                <Action bare mouseover={this.hold} />\n                <Action bare mouseleave={this.releaseHold} />\n\n                <div\n                    role=\"alert\"\n                    ref={this.alertsRef}\n                    className={\n                        hold ? \"tooltip tooltip-bottom tooltip-left\" : \"\"\n                    }\n                    {...tooltip}\n                    aria-relevant=\"additions\"\n                >\n                    {\" \"}\n                    {/*  aria-live=\"polite\"  - omitted to avoid double speaking issues in iOS per https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions#content */}\n                    {notices.map(({ severity, message }, i) => (\n                        <div\n                            aria-label={`${severity} notice`}\n                            key={i}\n                            className={`toast toast-${severity}`}\n                        >\n                            {this.mungeMessage(message)}\n                        </div>\n                    ))}\n                </div>\n            </>\n        );\n    }\n    mungeMessage(message) {\n        //! it displays a react element as-is\n        if (message.type && message.props) return message;\n\n        const t = message.split(\"\\n\").flatMap((m) => [\n            m,\n            <React.Fragment>\n                <br />\n                &nbsp;&nbsp;\n            </React.Fragment>,\n        ]);\n        t.pop();\n        return t;\n    }\n}\n","/home/san/dev/poshplum-next/packages/poshplum/src/actors/PortalRegistry.js",["329","330"],[],"/home/san/dev/poshplum-next/packages/poshplum/src/components/Chip.js",["331","332","333","334","335","336","337","338","339","340","341","342"],[],"import React from 'react';\n\nimport {Link} from 'react-router-dom';\nimport { Layout } from '../Layout';\n\nlet Title = Layout.defaultSlot(\"Title\").withMarkup(({className=\"\", children, ...props}) => {\n    return <span key=\"title\" className={`${className}`} {...props}>\n        <h6>\n            {children}\n        </h6>\n    </span>\n});\n// console.log(\"Title is \", Title, Title.displayName);\n\nlet Icon = Layout.namedSlot(\"Icon\").withMarkup(({className=\"\", icon, children, ...props}) => {\n    return <div key=\"icon\" className={`avatar avatar-sm ${className}`} {...props}>\n        {icon || children}\n    </div>\n});\n\nlet Label = Layout.namedSlot(\"Label\").withMarkup(({as:As=\"div\", className=\"\", icon, children, ...props}) => {\n    return <As key=\"label\" className={`float-right ${className}`} {...props}>\n        {icon || children}\n    </As>\n});\n\nlet Body = Layout.namedSlot(\"Body\").withMarkup(({as:As=\"div\", className=\"\", children, ...props}) => {\n    return <As className={`footnote ml-2 ${className}`} {...props}>\n        {children}\n    </As>\n});\n\nexport class Chip extends Layout {\n    static as=\"span\"\n    static Title = Title;\n    static Icon = Icon;\n    static Body = Body;\n    static Label = Label;\n    static slots = {Title, Icon, Body, Label};\n\n    constructor() {\n        super()\n        this._link = React.createRef()\n    }\n    render() {\n        let {active, as: As=\"span\", halfWidth, fullWidth, compact, multiLine, tabIndex=\"0\", onClick, item, debug, match, children, wrapperProps, wrapperClassName=\"\", className=\"\", link, render, ...otherProps} = this.props;\n        let {Title, Icon, HeaderRight, Body, Footer, Label} = this.slots;\n\n        let multiLineClass=\"\"; if (multiLine) multiLineClass='multiLine'\n        if (compact) className += \" compact\";\n        if (link && !onClick) {\n            onClick = () => {\n                this._link.current && this._link.current.context.router.history.push(link)\n            } };\n\n        // let clickFn = (e) => { if (cardItemClicked) cardItemClicked(item) };\n        const showScreaderLink = link && <Link to={link} ref={this._link} className=\"screader\">{Title || \"expand\"}</Link>;\n\n        const widthClass=fullWidth ? \"full-width\" : halfWidth ? \"half-width\" : \"\";\n        if (debug) debugger;\n        let chip = <As {...wrapperProps} onClick={onClick} className={`chip-wrapper d-inline-block ${widthClass} ${wrapperClassName} ${active ? \"active\" : \"\"}`}>\n            {Icon}\n            <As {...otherProps} tabIndex={tabIndex} className={`chip ${multiLineClass} ${className} ${active ? \"active\" : \"\"}`}>\n                {Label}\n                {Title}\n                {link && Title && showScreaderLink}\n\n                {multiLine && Body && <div className=\"flex-break-line\"></div>}\n                {Body}\n\n                {link && !Title && showScreaderLink}\n            </As>\n        </As >;\n\n        return chip;\n    }\n};\n\n","/home/san/dev/poshplum-next/packages/poshplum/src/components/ErrorTrigger.js",["343"],[],"import React from \"react\";\n\nimport { Reactor } from \"../Reactor\";\n\nexport class ErrorTrigger extends React.Component {\n    render() {\n        const { children, className } = this.props;\n        this.node = this.node || React.createRef();\n        if (!children || (Array.isArray(children) && !children.length)) {\n            return <span className={className} ref={this.node} />;\n        }\n\n        return (\n            <div className={className} ref={this.node}>\n                {children}\n            </div>\n        );\n    }\n    componentDidMount() {\n        let { error } = this.props;\n        if (!error)\n            throw new Error(`ErrorTrigger missing required error= prop`);\n        Reactor.trigger(this.node.current, \"error\", {\n            error: error,\n            single: true,\n        });\n    }\n}\n","/home/san/dev/poshplum-next/packages/poshplum/src/components/FormSection.js",[],[],"/home/san/dev/poshplum-next/packages/poshplum/src/components/Notification.js",["344","345","346"],[],"import React from \"react\";\nimport { Reactor } from \"../Reactor\";\n\nexport class Notification extends React.Component {\n    render() {\n        const { children, className } = this.props;\n        this.node = this.node || React.createRef();\n        if (!children || (Array.isArray(children) && !children.length)) {\n            return <span className={className} ref={this.node} />;\n        }\n\n        return (\n            <div className={className} ref={this.node}>\n                {children}\n            </div>\n        );\n    }\n    componentDidMount() {\n        let { success, warning, error } = this.props;\n        const severity =\n            (success && \"success\") ||\n            (warning && \"warning\") ||\n            (error && \"error\");\n        const message = this.props[severity];\n        if (!message)\n            throw new Error(\n                `Notification missing message in one of {success=, warning=, error=} props`\n            );\n        Reactor.trigger(this.node.current, severity, {\n            [severity]: message,\n            single: true,\n        });\n    }\n}\n","/home/san/dev/poshplum-next/packages/poshplum/src/components/SectionTitle.js",["347"],[],"/home/san/dev/poshplum-next/packages/poshplum/src/docs.tsx",["348"],[],"/home/san/dev/poshplum-next/packages/poshplum/src/helpers/ClassNames.js",[],[],"/home/san/dev/poshplum-next/packages/poshplum/src/helpers/isOutsideDOM.js",[],[],"/home/san/dev/poshplum-next/packages/poshplum/src/helpers/matchChildType.js",["349","350"],[],"/home/san/dev/poshplum-next/packages/poshplum/src/helpers/mousetrap.js",["351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","366","367","368","369","370","371","372","373","374","375","376","377","378","379","380","381","382","383","384","385","386","387","388"],[],"/home/san/dev/poshplum-next/packages/poshplum/src/index.ts",[],[],"/home/san/dev/poshplum-next/packages/poshplum/src/main.tsx",[],[],"/home/san/dev/poshplum-next/packages/poshplum/src/reactor/index.ts",[],[],"/home/san/dev/poshplum-next/packages/poshplum/src/vite-env.d.ts",[],[],"/home/san/dev/poshplum-next/packages/poshplum/vite.config.ts",[],[],"/home/san/dev/poshplum-next/packages/utils/platform/browser/SubtleCrypto.js",["389","390","391"],[],"\nexport let PlatformSubtleCrypto = (self || window).crypto.subtle;\n","/home/san/dev/poshplum-next/packages/utils/platform/browser/TextEncoder.js",["392"],[],"/home/san/dev/poshplum-next/packages/utils/platform/browser/child_process.js",[],[],"/home/san/dev/poshplum-next/packages/utils/platform/browser/logDestination.js",["393","394","395","396"],[],"/home/san/dev/poshplum-next/packages/utils/platform/browser/os.js",[],[],"/home/san/dev/poshplum-next/packages/utils/platform/browser/stdout.js",[],[],"/home/san/dev/poshplum-next/packages/utils/platform/server/SubtleCrypto.js",["397"],[],"\nimport { subtle } from 'node:crypto';\n\nexport let PlatformSubtleCrypto = subtle;\n","/home/san/dev/poshplum-next/packages/utils/platform/server/TextEncoder.js",[],[],"/home/san/dev/poshplum-next/packages/utils/platform/server/child_process.js",["398"],[],"/home/san/dev/poshplum-next/packages/utils/platform/server/logDestination.js",["399","400","401","402","403","404"],[],"import { child_process } from \"@platform/child_process\";\n\nimport dotenv from 'dotenv'\nconst envFile = process.env.ENV_FILE;\nconst cfg = envFile ? dotenv.config({ path: envFile }) : {};\n// import { configFromEnvironmentFile } from \"@platform/Config\";\n// const config = configFromEnvironmentFile && configFromEnvironmentFile();\n\nimport createLogger from \"pino\";\n\n  \nexport function logDestination() {\n    const adapter = localEnv(\"DB_ADAPTER\");\n    if (\"http\" !== adapter) {\n        // default destination (stdout) in development\n        return createLogger.destination();\n    } else {\n        if (child_process && \"development\" === process.env.NODE_ENV) {\n            if (!!parseInt(localEnv(\"SKIP_DB_LOGGING\"))) {\n                console.log(\n                    `SKIPPING db logging due to SKIP_DB_LOGGING env variable (DEV notice)`\n                );\n                return createLogger.destination();\n            }\n        }\n\n        const connectionURL = localEnv(\"DB_ROOT\")\n        const logDb = localEnv(\"DB_logs\")\n        const user = localEnv(\"DB_USERNAME\")\n        const pass = localEnv(\"DB_PASSWORD\")\n        const connectionString = connectionURL.replace(\n            /^(http[s]?:\\/\\/)/,\n            (match, prefix) => `${prefix}${user}:${pass}@`\n        );\n        console.log(\"spawning log/database bridge - \" + __dirname);\n        const dir =\n            \"development\" === process.env.NODE_ENV ? \".\" : `${__dirname}/..`; // in production, node_modules rides next to server/  - not necessary for an important reason.\n        debugger;\n        const worker = child_process.spawn(\n            `${dir}/node_modules/.bin/pino-couch`,\n            [\"--quiet\", \"-U\", connectionString, \"-d\", logDb],\n            {\n                stdio: [\"pipe\", \"inherit\", \"inherit\"],\n            }\n        );\n        return worker.stdin;\n    }\n}\nlogDestination.localEnv = localEnv;\n\nfunction localEnv(key) {\n    return process.env[key]\n  }\n","/home/san/dev/poshplum-next/packages/utils/platform/server/os.js",["405","406","407"],[],"/home/san/dev/poshplum-next/packages/utils/platform/server/stdout.js",[],[],"/home/san/dev/poshplum-next/packages/utils/rollup.browser.config.js",["408","409","410"],[],"import dts from \"rollup-plugin-dts\";\nimport typescript from \"rollup-plugin-ts\";\nimport commonjs from \"@rollup/plugin-commonjs\";\nimport replace from \"@rollup/plugin-replace\";\n\n// not needed for browser\nimport externals from \"rollup-plugin-node-externals\";\n\nimport { join } from \"path\";\nconst modulePaths = [join(process.cwd(), \"platform/browser/\")];\n\n// used for finding modules to bundle, using Node's resolution algo\nimport resolve from \"@rollup/plugin-node-resolve\";\nimport alias from \"@rollup/plugin-alias\";\n\nconst name = require(\"./package.json\").main.replace(/\\.js$/, \"-browser\");\n\nconst bundledModules = [\n    \"zoned-cls\",\n    \"@platform/child_process\",\n    \"@platform/Config\",\n    \"@platform/logDestination\",\n    \"@platform/os\",\n    \"@platform/stdout\",\n    \"@platform/os\",\n    \"@platform/TextEncoder\",\n    \"@platform/SubtleCrypto\",\n];\nconst forcedExternals = [];\n\n//! see rollup.browser.config.js for the browser build\nconst browserBundle = (config) => ({\n    ...config,\n    input: \"./src/index-browser.ts\",\n    external: (id) => {\n        if (bundledModules.includes(id)) return false;\n        if (forcedExternals.includes(id)) return true;\n        // console.warn(\"---ext detect ---\", id)\n        \n        return !/^[./]/.test(id);\n    },\n});\n\nconst watchDeps = {\n    name: \"dev-deps\",\n    async buildStart() {\n        this.addWatchFile(\"./rollup.browser.config.js\");\n    }\n}\n\nexport default [\n    browserBundle({\n        plugins: [\n            watchDeps,\n            externals(),\n            resolve({\n                browser: true,\n                modulePaths,\n            }),\n            replace({\n                preventAssignment: true,\n                'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n                'process.env.WIDE_OPEN_UNSAFE': JSON.stringify(process.env.WIDE_OPEN_UNSAFE || false),\n            }),\n            commonjs({\n                include: \"../../zoned-cls/dist/zoned-cls.js\",\n            }),\n            typescript(),\n        ],\n        output: [\n            {\n                file: `${name}.js`,\n                format: \"cjs\",\n                sourcemap: true,\n            },\n            {\n                file: `${name}.mjs`,\n                format: \"es\",\n                sourcemap: true,\n            },\n        ],\n    }),\n    browserBundle({\n        plugins: [dts()],\n        output: {\n            file: `${name}.d.ts`,\n            format: \"es\",\n        },\n    }),\n];\n","/home/san/dev/poshplum-next/packages/utils/rollup.config.js",["411","412","413"],[],"/home/san/dev/poshplum-next/packages/utils/src/CryptoHelper.js",["414","415","416","417","418","419","420","421","422","423","424","425","426","427","428","429","430"],[],"let helperClass;\n\nimport {PlatformTextEncoder} from \"@platform/TextEncoder\";\nimport {PlatformSubtleCrypto} from \"@platform/SubtleCrypto\";\n\nexport class CryptoHelper {\n    static async sign(plainText, privateKey) {\n        if (navigator.hi) console.log('hi3');\n        // console.warn({plainText, privateKey}, new Error(\"stack\"));\n        if (!privateKey) throw new Error(\"signing requires a privateKey\");\n        let plainBuffer = new PlatformTextEncoder(\"utf-8\").encode(plainText);\n        let signature = await PlatformSubtleCrypto.sign(\n            {\n                name: \"RSA-PSS\",\n                saltLength: 128, //the length of the salt\n            },\n            privateKey,\n            plainBuffer\n        );\n\n        return signature;\n    }\n    static async signToHex(plainText, privateKey) {\n        return this.array2hex(await this.sign(plainText, privateKey));\n    }\n\n    static async verifyHex(plainText, hexSignature, publicKey) {\n        let signature = this.hexToArrayBuffer(hexSignature);\n\n        return this.verify(plainText, signature, publicKey);\n    }\n    static async hash(content, algo = \"SHA-256\") {\n        const encoder = new PlatformTextEncoder();\n        const data = encoder.encode(content);\n        let result = await PlatformSubtleCrypto.digest(algo, data);\n\n        return this.array2hex(result);\n    }\n\n    static async verifyJwk(jwkString) {\n        if (\"string\" !== typeof jwkString) {\n            throw new Error(\"publicKey needs to be stringified\");\n        }\n        let jwk = JSON.parse(jwkString);\n        if (!(jwk.kty && jwk.n && jwk.e)) throw new Error(\"Not a jwk\");\n        if (jwk.n.length > 683)\n            throw new Error(\"key length > 4096 bits not accepted\");\n        if (jwk.d) throw new Error(\"refusing to save a private key\");\n\n        const key = await CryptoHelper.importPublicKeyJWK(jwk);\n        if (key.algorithm.modulusLength < 2048)\n            throw new Error(\"publicKey needs to be 2048 bits minimum\");\n        return key;\n    }\n\n    static array2hex(buffer) {\n        const byteArray = new Uint8Array(buffer);\n        const hexCodes = [...byteArray].map((value) => {\n            const hexCode = value.toString(16);\n            const paddedHexCode = hexCode.padStart(2, \"0\");\n            return paddedHexCode;\n        });\n\n        return hexCodes.join(\"\");\n    }\n    static hexToArrayBuffer(hex) {\n        if (typeof hex !== \"string\") {\n            throw new TypeError(\"Expected input to be a string\");\n        }\n\n        if (hex.length % 2 !== 0) {\n            throw new RangeError(\n                \"Expected string to be an even number of characters\"\n            );\n        }\n\n        var view = new Uint8Array(hex.length / 2);\n\n        for (var i = 0; i < hex.length; i += 2) {\n            view[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n        }\n\n        return view.buffer;\n    }\n\n    static async verify(plainText, signature, publicKey) {\n        // console.warn(new Error(\"stack\"))\n        let plainBuffer = new PlatformTextEncoder(\"utf-8\").encode(plainText);\n        let result = await PlatformSubtleCrypto.verify(\n            { name: \"RSA-PSS\", saltLength: 128 },\n            publicKey,\n            signature,\n            plainBuffer\n        );\n        return result;\n    }\n\n    static async importSigningKeyJWK(jwk) {\n        return PlatformSubtleCrypto.importKey(\n            \"jwk\",\n            jwk,\n            { name: \"RSA-PSS\", hash: \"SHA-256\" },\n            false,\n            [\"sign\"]\n        );\n    }\n    static async importPublicKeyJWK(jwk) {\n        return PlatformSubtleCrypto.importKey(\n            \"jwk\",\n            jwk,\n            { name: \"RSA-PSS\", hash: \"SHA-256\" },\n            true,\n            [\"verify\"]\n        );\n    }\n\n    static async createJwk(bits) {\n        if (!bits)\n            throw new Error(\n                \"CryptoHelper.createJwk(bits): required arg missing (use 2048 or 4096)\"\n            );\n        let key = await this.generateKey(bits);\n\n        return await this.toJwk(key.publicKey);\n    }\n\n    static async toJwk(publicKey) {\n        return await PlatformSubtleCrypto.exportKey(\"jwk\", publicKey);\n    }\n\n    // static async importSigningKey(key) {\n    //   return await subtle.importKey(\"jwk\", key, {\n    //     name: \"RSA-PSS\",\n    //       hash: \"SHA-256\",\n    //     publicExponent: new Uint8Array([1, 0, 1]),\n    //     modulusLength: 2048,\n    //   }, false, [\"sign\"])\n    // }\n\n    static async keyPrint(publicKey) {\n        if (!publicKey) return null;\n\n        let keyJwk = await this.toJwk(publicKey);\n        if (!keyJwk) {\n            console.warn(\"no jwk\");\n            return null;\n        }\n        let { e, kty, n } = keyJwk;\n        if (!(e && kty && n)) {\n            throw new Error(\"jwk doesn't have required entries\");\n        }\n\n        let hash = await this.hash(JSON.stringify({ e, kty, n }));\n        return hash.slice(0, 10);\n    }\n\n    static async generateKey(bits) {\n        let key = await PlatformSubtleCrypto.generateKey(\n            {\n                name: \"RSA-PSS\",\n                modulusLength: bits,\n                publicExponent: new Uint8Array([1, 0, 1]),\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"sign\", \"verify\"]\n        );\n        return key;\n    }\n}\n","/home/san/dev/poshplum-next/packages/utils/src/StateMachine.js",["431","432","433","434","435","436","437","438","439","440","441","442","443","444","445","446","447","448","449","450","451","452","453","454","455","456","457","458","459","460","461","462","463","464","465","466","467","468","469","470","471","472","473","474","475","476","477","478"],[],"import cloneDeep from \"lodash/cloneDeep.js\";\n\nimport { forkZoneWithContext, forkZoneWithLogger, ZonedStackTrace } from \"./zonedLogger\";\n\nimport { hasError } from \"./hasError\";\n\nclass UnmetPredicate extends Error {\n    static retriable = false;\n    retriable = false;\n}\nclass InvalidTransition extends ZonedStackTrace {\n    static retriable = false;\n    retriable = false;\n}\n\n// usage: Create a state machine by using the GenericStateMachine's\n//     factory-method withDefinition({...machineStates}).\n//\n//  An oversimplified machine could look like this:\n//    const machineStates = {\n//      { green: { warnTraffic: \"yellow\" } },\n//      { yellow: { stopTraffic: \"red\" } },\n//      { red: { allowTraffic: \"green\", default: true } },\n//    }\n//\n//  This example could work in the real world, given another software module that decides\n//    when to trigger allowTraffic and the other transitions.  A version closer to realistic\n//    might look like this:\n//\n//    machineStates: {\n//      red: { default: true, onEntry() { return camera.enforceLaw() },\n//        allowTraffic: \"green\",\n//      },\n//      green: { onEntry() { return watchForCrossTraffic() },\n//        warnTraffic: { nextState: \"yellow\", effect() { return stopWatchingCrossTraffic() } }\n//      }\n//      yellow: { onEntry() { delayedRed() }\n//        stopTraffic: \"red\",\n//      }\n//    };\n//\n//  The states are defined as key/value pairs, where the key is the\n//     name of the state, and the value is an object having one\n//     or more transitions (defined below) and a few special keys:\n//\n//      * default: true        // makes it the default state; optional if there is a state named default\n//      * label: \"string\"      // gives a friendlier string, e.g. for onscreen display\n//      * onEntry: ‹function›  // called when the machine enters this state.  You can trigger\n//                             //  automatic transitions from this callback.\n//\n//   We recommend state names be clear, static-sounding words.  \"-ing\" and \"-ed\" words are typically good choices.\n//\n//   The transitions defined for each state are also key/values.  The keys are transition names; we recommend\n//      these sound like commands (\"start\", \"search\") or indications that something happened (\"opened\", \"thingAdded\").  \n//      Values can either be a simple string (the name of the next state resulting from this transition) or an object with \n//      nextState and optional callbacks for {predicate, effect}:\n//\n//      * nextState: string    // the next state that the machine will be in when this transition is triggered.\n//      * predicate: function  // if defined, it can allow or block the transition by returning true/false.\n//                             //   *** do not trigger transitions from this function.  Can be an async function.\n//      * effect: function     // if defined, this indicates a side-effect to be triggered before the machine\n//                             //   changes to nextState.\n//                             //   *** do not trigger transitions from this function.  Can be an async function.\n//      * reEntry: boolean     // for a transition that leads from the current state back to the same state, this\n//                             //   boolean attributes specifies that the `onEntry()` MUST be re-run.\n//\n//  All callbacks can be async functions, whose pending promises will block progress of the state machine.\n//\n//  Integration: A state machine class can also define an onTransition() method, useful for integrating the\n//    state-machine with an outside module (i.e. for reflecting the effect of the state having changed).  And a\n//    state-machine instance can further define a contextObject property, to which callbacks will be bound - as\n//    if those callbacks were defined in the contextObject's class.\n//\n//  Here's an other example showing all (??) of these together:\n//\n//  class MyStateMachine extends GenericStateMachine.withDefinition(\n//    {\n//      blocked: {\n//        label: \"--- pending host info ---\",\n//        default: true,\n//        detect: \"detecting\",\n//      },\n//      detecting: {\n//        onEntry() { this.installError = null },\n//        needsInstall: \"installing\",\n//        detectedLinux: \"preparingAccounts\",\n//        failed: \"failed\",\n//        rescan: { nextState: \"detecting\", reEntry: true }\n//      },\n//      preparingAccounts: {\n//        onEntry() { this.installError = null },\n//        success: \"done\",\n//        \"connectionFailed\": \"failed\",\n//      },\n//      \"preparingAccounts\": {\n//        async onEntry() {\n//          if (this.configurationSatisfied()) return this.transition('startConfiguring')\n//        },\n//        rescan: \"detecting\",\n//        startConfiguring: {\n//          predicate() { return this.configurationSatisfied() },\n//          nextState: \"configuring\",\n//        }\n//      }\n//    }\n//  ) { ... }\n//\n\nexport class StateMachine {\n    constructor({\n        currentState,\n        contextObject,\n        contextLabel,\n        logFacility,\n        logProperties = {},\n    }) {\n        // TODO: test perf changes with these\n        this.currentState = currentState;\n        //  //  this._stateValues = null;\n        //  they should give better optimization opportunities to V8\n\n        this.contextObject = contextObject || this;\n        this.contextLabel = contextLabel;\n        this.logFacility = logFacility || \"stateMachine\";\n        this.logProperties = logProperties;\n        this.recentGeneration = 0;\n    }\n    mkTransition(transitionName) {\n        return this.transition.bind(this, transitionName)\n    }\n\n    static withDefinition(machineDef, name, options = {}) {\n        if (!name)\n            throw new Error(\n                `StateMachine.withDefinition(def, name): missing required 'name' of state-machine`\n            );\n\n        let defaultState = machineDef.default && \"default\";\n        if (!defaultState)\n            for (const [\n                defaultStateName,\n                { default: isDefault },\n            ] of Object.entries(machineDef)) {\n                if (isDefault) {\n                    defaultState = defaultStateName;\n                    break;\n                }\n            }\n        if (!defaultState)\n            throw new Error(`Each state machine requires a default state`);\n\n        const { asyncEnhancements = false } = options;\n        return class DefinedStateMachine extends StateMachine {\n            //! it allows the definition to include options, which are transparently\n            //  available on the resulting state-machine class as a static member\n            static get options() {\n                return options;\n            }\n\n            static get name() {\n                return name;\n            }\n            get name() {\n                return name;\n            }\n\n            static get defaultState() {\n                return defaultState;\n            }\n            get defaultState() {\n                return defaultState;\n            }\n\n            static get def() {\n                throw new Error(\"where is this used?\");\n                return machineDef;\n            }\n            get def() {\n                if (asyncEnhancements && this.enhanced) return this.enhanced;\n                if (this._enhancing)\n                    throw new Error(\n                        `can't get def synchronously with a pending async enhancement`\n                    );\n                return machineDef;\n            }\n            get asyncEnhancements() {\n                return asyncEnhancements;\n            }\n\n            delegateSetupTrigger(triggerFunction) {\n                if (this._enhancementTrigger) {\n                    debugger\n                    throw new Error(`can't set a second delegateSetupTrigger`)\n                }\n\n                const enhancementTrigger = (this._enhancementTrigger = async () => {\n                    const enhancements = await triggerFunction();\n                    return this.enhanceWith(enhancements);\n                });\n                return enhancementTrigger;\n            }\n\n            async enhanceWith(enhancementPromise) {\n                let enhanceDone, enhanceFailed;\n                this._enhancing = new Promise((res, rej) => {\n                    enhanceDone = res;\n                    enhanceFailed = rej;\n                });\n                const enhancement = await enhancementPromise;\n\n                const enhancing = cloneDeep(machineDef);\n                for (const [stateName, enhancementStateDef] of Object.entries(\n                    enhancement\n                )) {\n                    const origStateDef = machineDef[stateName];\n\n                    const label = `${this.name}@${stateName}`;\n                    if (!origStateDef) {\n                        enhancing[stateName] = enhancementStateDef;\n                        //!!! todo add logger\n                        // logger.progress(\n                        //     { summary: { label, stateDef } },\n                        //     \"enhanced with new state\"\n                        // );\n                        continue;\n                    }\n\n                    const enhancingThisState = enhancing[stateName];\n\n                    for (const [\n                        transName,\n                        enhancementTransDef,\n                    ] of Object.entries(enhancementStateDef)) {\n                        const origTransDef = origStateDef?.[transName];\n                        if (!origTransDef) {\n                            enhancingThisState[transName] = enhancementTransDef;\n                            //!!! todo add logger\n                            // console.warn(\n                            //     { summary: { label, stateDef, transName } },\n                            //     \"adding transition\"\n                            // );\n\n                            continue;\n                        }\n\n                        const enhancingThisTrans =\n                            enhancingThisState[transName];\n                        // at this point, this state existed already, and we have an enhancment to apply to it\n                        // if that enhancement is an onEntry hook...\n\n                        if (transName == \"onEntry\") {\n                            const { onEntry: origOnEntry } = origStateDef;\n\n                            //! it adds onEntry to an existing state not having one, if provided by the enhancement\n                            if (!origOnEntry) {\n                                enhancingThisState.onEntry =\n                                    enhancementTransDef;\n                                continue;\n                            }\n\n                            //! if the base machine has an onEntry() it chains the enhancement's onEntry() after it.\n                            const enhancedOnEntry = enhancementTransDef;\n                            const machine = this;\n                            enhancingThisState.onEntry = async function (\n                                machineArg\n                            ) {\n                                const { currentState: entryState } = machine;\n                                try {\n                                    await origOnEntry.apply(this, arguments);\n                                } catch (e) {\n                                    throw e;\n                                }\n\n                                //! it honors the priority of the base machine's onEntry(), if it transitions to a different state\n                                //    - and doesn't call the enhancement's onEntry()\n                                //    NOTE: if this is a problem, consider any pending use-cases in any proposed change.\n                                const nextState = machine.currentState;\n                                if (entryState == nextState) {\n                                    return enhancedOnEntry.apply(\n                                        this,\n                                        arguments\n                                    );\n                                } else {\n                                    // logger.progress({summary:{name: this.name, nextState}}, `baseline onEntry() asserted control over implicit transition to next state`)\n                                }\n                            };\n                            continue;\n                        }\n\n                        // At this point, the transition name existed already, and we have an enhancement to apply to it\n\n                        // console.warn( `merging transition '${transName}'`);\n\n                        const origNextState = nextState(origTransDef);\n                        const enhancedNextState =\n                            nextState(enhancementTransDef);\n                        //! doesn't allow override of the semantics of a transition by redirecting it to a different state.\n                        if (origNextState && enhancedNextState) {\n                            throw new Error(\n                                `Enhancement can't redirect an established transition to a different state: ${label}: ${transName} -> ${origNextState}`\n                            );\n                        }\n                        const enhancementPredicate =\n                            enhancementTransDef.predicate;\n                        if (enhancementPredicate) {\n                            if (!origTransDef.predicate) {\n                                enhancingThisTrans.predicate =\n                                    enhancementPredicate;\n                                continue;\n                            }\n                            enhancingThisTrans.predicate =\n                                async function composedPredicate(machine) {\n                                    try {\n                                        const result =\n                                            await origTransDef.predicate.call(\n                                                this,\n                                                machine\n                                            );\n                                        if (!result) return result;\n                                    } catch (e) {\n                                        throw e;\n                                    }\n                                    return enhancementPredicate.call(\n                                        this,\n                                        machine\n                                    );\n                                };\n                        }\n\n                        const enhancementEffect = enhancementTransDef.effect;\n                        if (enhancementEffect) {\n                            debugger;\n                            if (!origTransDef.effect) {\n                                enhancingThisTrans.effect = enhancementEffect;\n                                continue;\n                            }\n                            enhancingThisTrans.effect =\n                                async function composedEffects(machine) {\n                                    try {\n                                        await origTransDef.effect.call(\n                                            this,\n                                            machine\n                                        );\n                                        debugger;\n                                    } catch (e) {\n                                        //!!! todo use logger\n                                        const e2 = ZonedStackTrace.fromError(e);\n                                        console.warn(\n                                            `in state machine ${this.name}: error  in base effect: `,\n                                            e2.stack()\n                                        );\n                                        console.warn(\n                                            `Continuing to execute stacked effect from delegate after base effect error in state machine ${this.name}`\n                                        );\n                                    }\n                                    return enhancementEffect.call(\n                                        this,\n                                        machine\n                                    );\n                                };\n                        }\n                    }\n                }\n                let { currentState = this.defaultState } = this;\n\n                if (!enhancement[currentState]) {\n                    const fail = new ZonedStackTrace(\n                        `${this.name}: state ${currentState} is invalid`\n                    );\n                    const failedPromise = this._enhancing;\n                    this._enhancing = fail;\n                    enhanceFailed(fail);\n                    return failedPromise;\n                }\n\n                this._enhancing = undefined;\n                this._stateValues = undefined;\n                this.enhanced = enhancing;\n                enhanceDone(enhancement); // delayed resolution of promise for the enhancement\n                return enhancing;\n\n                function nextState(transDef) {\n                    return \"string\" === typeof transDef\n                        ? transDef\n                        : transDef.nextState;\n                }\n            }\n\n            get label() {\n                return `${name} @${this.currentState}`;\n            }\n        };\n    }\n\n    get stateValues() {\n        if (this._stateValues) return this._stateValues;\n        const labels = {};\n        for (const [statename, { label = statename }] of Object.entries(\n            this.def\n        )) {\n            if (\"apiActions\" === statename) continue;\n            labels[statename] = label;\n        }\n        return (this._stateValues = labels);\n    }\n    validateState(state) {\n        if (!state) return false;\n        const def = this.def;\n        if (def[state]) return state;\n        throw new Error(`invalid state ${state}`);\n    }\n    get currentState() {\n        throw new Error(\n            `currentState getter must be implemented by your State Machine adapter`\n        );\n    }\n    set currentState(newState) {\n        throw new Error(\n            `currentState setter must be implemented by your State Machine adapter`\n        );\n    }\n    hasEffectiveTransition(transitionName) {\n        return this.hasTransition(transitionName, \"effective\");\n    }\n    hasTransition(transitionName, requireEffectiveTransition) {\n        let { currentState = this.defaultState } = this;\n        let thisState = this.def[currentState] || this.def[this.defaultState];\n\n        let {\n            onEntry,\n            default: isDefaultState,\n            ...goodTransitions\n        } = thisState;\n\n        let transition = goodTransitions[transitionName];\n        if (typeof transition === \"string\")\n            transition = { nextState: transition };\n        if (transition && requireEffectiveTransition) {\n            if (transition.nextState == currentState && !transition.reEntry)\n                return false;\n        }\n        return !!transition;\n    }\n\n    nextState(transitionName) {\n        let { currentState = this.defaultState } = this;\n        let thisState = this.def[currentState] || this.def[this.defaultState];\n        let {\n            onEntry,\n            default: isDefaultState,\n            ...goodTransitions\n        } = thisState;\n\n        if (\"default\" == transitionName) {\n            if (isDefaultState || \"default\" == currentState) {\n                return currentState;\n            }\n        }\n\n        let transition = goodTransitions[transitionName];\n\n        if (typeof transition === \"string\")\n            transition = { nextState: transition };\n\n        let nextState =\n            (transition && transition.nextState) || \"‹undefined transition›\";\n\n        return nextState;\n    }\n    contextInfo() {\n        let { currentState = this.defaultState } = this;\n        return `🗜️${this.contextLabel} @${currentState}`;\n    }\n    transitionContextInfo(transitionName) {\n        return `${this.contextInfo()} transition ${transitionName}⦡ ${this.nextState(\n            transitionName\n        )}`;\n    }\n\n    async transition(transitionName) {\n        const location = new ZonedStackTrace();\n        const transitionContext = this.transitionContextInfo(transitionName);\n        let label = this.label || this.constructor.name;\n\n        if (this.asyncEnhancements) {\n            if (!this.enhanced) {\n                if (this._enhancing) {\n                    await this._enhancing;\n                } else if (this._enhancementTrigger) {\n                    debugger;\n                    await this._enhancementTrigger.call(this);\n                }\n\n                // this.enhanced isn't filled if there's no delegate record.\n                //   if (!this.enhanced) throw new Error(`enhanced should be filled after enhancements`);\n            }\n        }\n\n        const stateMachineName = `state-machine: ${label}`;\n\n        const logProps = {\n            transitionName,\n            ...this.logProperties,\n        };\n        const logLevel = this.def.logLevel;\n        if (logLevel) {\n            logProps.levels = {\n                [this.logFacility]: logLevel,\n                _message: `state-machine: ${this.name} definition`,\n            };\n        }\n        let transitionZone = forkZoneWithLogger(this.logFacility, logProps, {\n            name: stateMachineName,\n            properties: {\n                location,\n                addContext: transitionContext,\n            },\n        });\n        let logger = transitionZone.get(\"logger\");\n        return transitionZone.run(\n            this.transitionInZone.bind(this, transitionName)\n        );\n    }\n    async optionalTransition(transitionName) {\n        try {\n            const result = await this.transition(transitionName);\n            return result;\n        } catch (e) {\n            if (e instanceof UnmetPredicate) return false;\n            if (e instanceof InvalidTransition) return false;\n            console.warn(\n                \"optionalTransition: non-predicate error: \",\n                e.stack || e\n            );\n            //   Zone.current.get(\"logger\").warn({detail:{error: e.stack || e}}, \"optionalTransition: non-predicate error\")\n            throw e;\n        }\n    }\n    async transitionInZone(transitionName) {\n        let logger = Zone.current.get(\"logger\");\n\n        if (this._enhancing) await this._enhancing;\n\n        let { currentState = this.defaultState } = this;\n        let machineLabel = this.label || this.constructor.name;\n        let shortLabel = this.shortLabel || this.constructor.name;\n\n        let thisState = this.def[currentState];\n        if (!thisState)\n            throw new Error(\n                `${machineLabel}: bad current state ${currentState}`\n            );\n        let {\n            onEntry,\n            default: isDefaultState,\n            label,\n            ...goodTransitions\n        } = thisState;\n        const contextObject = this.contextObject || this;\n\n        let transition = goodTransitions[transitionName];\n\n        if (typeof transition === \"string\")\n            transition = { nextState: transition };\n        // const stateMachineName = `state-machine: ${machineLabel}`;\n\n        let nextState = this.nextState(transitionName),\n            isDefaultTransition;\n        if (\"default\" == transitionName) {\n            if (isDefaultState || \"default\" == currentState) {\n                isDefaultTransition = true;\n                transitionName = \"default-state onEntry\";\n            }\n        }\n\n        if (isDefaultTransition) {\n            const msg = `default transition`;\n            logger.progressInfo(\n                { detail: { transition: transitionName } },\n                msg\n            );\n            this.recentGeneration++;\n            if (onEntry) {\n                const zone = forkZoneWithContext(\n                    `🗜️${shortLabel} ↝ ${transitionName} onEntry()`\n                );\n\n                this.needsDefaultTransition = undefined;\n                return zone.run(onEntry.bind(contextObject, this));\n            }\n            return;\n        }\n        if (this.needsDefaultTransition) {\n            const msg =\n                true === this.needsDefaultTransition\n                    ? \"\"\n                    : `(${this.needsDefaultTransition})`;\n\n            throw new ZonedStackTrace(\n                `${machineLabel}: has not run its defaultTransition yet ${msg}`\n            );\n        }\n\n        if (!transition) {\n            if (transitionName !== \"onUpdate\")\n                logger.progressInfo(\n                    {\n                        summary: `${machineLabel}: invalid: ${transitionName}`,\n                        detail: {\n                            transitionName,\n                            stack: new Error(\"called from\"),\n                        },\n                    },\n                    `throwing InvalidTransition`\n                );\n            //      debugger\n            throw new InvalidTransition(`${machineLabel}: INVALID transition('${transitionName}') from state '${currentState}' \n  (suggested: ${\n      Object.keys(goodTransitions).join(\",\") ||\n      \"‹none! this state appears to be terminal›\"\n  })}`);\n        }\n        let { predicate, effect, reEntry = false } = transition;\n\n        if (!transition.nextState)\n            throw new Error(\n                `${machineLabel}: INVALID transition definition '${transitionName}' from state '${currentState}'; should be string nextState or object {predicate,nextState,effect}`\n            );\n\n        const nextStateDef = this.def[nextState];\n\n        if (!nextStateDef) {\n            const msg = `${machineLabel}: INVALID target state in ${currentState}.transitions.${transitionName} -> state '${nextState}'`;\n\n            logger.error(\n                { detail: { currentState, transitionName, nextState } },\n                `invalid target state in transition definition`\n            );\n            const invalidTrans = new InvalidTransition(msg);\n            invalidTrans.stack =\n                invalidTrans.stack + \"\\n\" + Zone.current.get(\"location\").stack;\n            throw invalidTrans;\n        }\n        let pName = \"\";\n        if (predicate && \"predicate\" !== predicate.name) pName = predicate.name;\n\n        logger.progressInfo(\n            {\n                // detail: { transitionName },\n                summary: `${this.label} ⤻${transitionName} ${\n                    pName && `if(${pName}())`\n                } ➜ ${nextState}`,\n            },\n            `running transition`\n        );\n\n        if (predicate) {\n            if (typeof predicate !== \"function\")\n                throw new Error(\n                    `${machineLabel}: INVALID predicate (${predicate}); function required.\\n...in transition(${transitionName}) from state '${currentState}'`\n                );\n\n            const logProps = {};\n            logProps.predicateName = pName || predicate.name;\n\n            const predicateZone = forkZoneWithContext(\n                `${shortLabel} @${currentState}: ⤻${transitionName}: predicate ${pName}(❓)`,\n                { logProps }\n            );\n            const predicateLogger = predicateZone.get(\"logger\");\n            const promise = predicateZone.run(predicate.bind(contextObject));\n            const predicateError = await hasError(promise);\n            if (predicateError) {\n                predicateLogger.error(\n                    {\n                        detail: {\n                            error: predicateError.stack || predicateError,\n                        },\n                    },\n                    `error thrown in transition predicate`\n                );\n                return promise;\n            }\n\n            const predicateResult = await promise;\n            if (\"undefined\" === typeof predicateResult) {\n                throw new Error(\n                    `${machineLabel}: INVALID predicate result (${predicateResult}) true/false required.\\n...in transition(${transitionName}) from state '${currentState}'`\n                );\n            }\n            if (predicateResult === false) {\n                const message = `${machineLabel}: ${currentState} ⤻${pName}${\n                    pName && \"(❌)\"\n                } in ${transitionName}↝ `;\n                predicateZone\n                    .get(\"logger\")\n                    .progressInfo(\n                        { summary: message },\n                        `predicate blocked transition`\n                    );\n                throw new UnmetPredicate(\n                    \"predicate blocked transition: \" + message\n                );\n            }\n        }\n\n        this.recentGeneration++;\n        const fromState = this.currentState.valueOf();\n        this.currentState = nextState;\n\n        if (effect) {\n            const zone = forkZoneWithContext(\n                `🗜️: ... ⤻${transitionName} effect() ➜ ${nextState}`\n            );\n            try {\n                await zone.run(effect.bind(contextObject, this));\n            } catch (e) {\n                e.message =\n                    `${machineLabel}: <-! ⤻${transitionName}: error in effect callback:\\n` +\n                    (e.message || e);\n                zone.get(\"logger\").warn(\n                    { detail: { error: e.message || e } },\n                    `error in effect callback`\n                );\n                throw e;\n            }\n        }\n        if (nextStateDef.onEntry) {\n            const changedState = fromState !== nextState.valueOf();\n\n            if (changedState || reEntry) {\n                const zone = forkZoneWithContext(\n                    `🗜️ ${shortLabel} ➜ ${nextState} onEntry()`\n                );\n\n                await zone.runWithWarnings(\n                    nextStateDef.onEntry.bind(contextObject, this)\n                );\n            } else {\n                logger.debug(`➜ ${nextState} has no defined onEntry`);\n            }\n        }\n\n        if (this.currentState != nextState) {\n            logger.consoleInfo(\n                {\n                    summary:\n                        `${machineLabel} ${pName&&\"⤻\"}${pName}${pName && \"(✓) \"} ➜ ` +\n                        `${nextState}:onEntry ⟹ ➜ ${this.currentState}`,\n                },\n                \" ✓ trampolined \"\n            );\n            // because it already transitioned to another state,\n            // we don't need to trigger the onTransition again.\n            if (this.onTransition)\n                logger.progressInfo(\n                    {\n                        summary: machineLabel,\n                    },\n                    \"      onTransition notification already pending\"\n                );\n\n            return;\n        }\n        //! uses a freshened machineLabel if the transition causes it to change\n        //   XXX didn't work for model's state-machine : (\n        //   machineLabel = this.label || this.constructor.name\n\n        //no further transition during the onEntry\n        logger.consoleInfo(\n            {\n                summary: `${machineLabel} ${pName}${\n                    pName && \"(✓) \"\n                } ➜ ${nextState}`,\n            },\n            \" ✓ transitioned\"\n        );\n\n        if (this.onTransition) {\n            const integrationHookZone = forkZoneWithContext(\"onTransition\");\n\n            const { recentGeneration } = this;\n\n            const result = await integrationHookZone.run(\n                this.onTransition.bind(contextObject, {\n                    transitionName,\n                    currentState,\n                    fromState,\n                    recentGeneration,\n                    logger: integrationHookZone.get(\"logger\"),\n                })\n            );\n            return result;\n        }\n    }\n}\nStateMachine.UnmetPredicate = UnmetPredicate;\nStateMachine.InvalidTransition = InvalidTransition;\n","/home/san/dev/poshplum-next/packages/utils/src/StateMachineNext.ts",["479","480","481","482","483","484","485","486","487","488","489","490","491","492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507","508","509","510","511","512","513","514","515","516","517","518","519","520","521","522","523","524","525","526","527","528","529","530","531","532","533","534","535","536","537","538"],[],"import cloneDeep from \"lodash/cloneDeep\";\n\nimport { forkZoneWithContext, forkZoneWithLogger, ZonedStackTrace } from \"./zonedLogger\";\n\nimport { hasError } from \"./hasError\";\n\nconst effectiveTransOnly = Symbol(\"effectiveTransOnly\");\n\nclass UnmetPredicate extends Error {\n    static retriable = false;\n    retriable = false;\n}\nclass InvalidTransition extends ZonedStackTrace {\n    static retriable = false;\n    retriable = false;\n}\n\nconst onEntry = Symbol(\"onEntry\");\nconst predicate = Symbol(\"predicate\");\nconst effect = Symbol(\"effect\");\nconst next = Symbol(\"next\");\n\n// ---------------------------------------------------\ntype validStates<SM> = keyof SM;\ntype transitions<T> = keyof T;\n\ntype machineCallback<SM, R = any> =\n    | ((this: SM) => Promise<R>)\n    | ((this: SM) => R);\n\ntype transitionDetails<SM> = {\n    next: validStates<SM>;\n    effect?: machineCallback<SM>;\n    predicate?: machineCallback<SM, boolean | never>;\n};\n\ninterface stateHooks<T> {\n    onEntry? : machineCallback<T>;\n}\n\ntype mDef<SM> = Record<validStates<SM>, sDef<SM>>;\ntype sDef<SM> = Record<keyOrOnEntry, transDef<SM> | machineCallback<SM>>;\ntype keyOrOnEntry = typeof onEntry | string;\n\ntype transDef<SM> = validStates<SM> | transitionDetails<SM>;\n\ntype MachineDefinition<SM> = mDef<SM>\nfunction mkStateMachine<T extends MachineDefinition<T>>(\n    machineDefinition: T\n): T {\n    return machineDefinition;\n}\n  const t = mkStateMachine({\n    stateName1: {\n        anyProcessName: \"stateName2\",\n        anotherArbitraryProcessName: \"stateName1\",\n        //! success: validates badStateName\n        allowableProcessName: \"badStateName\",\n        something: { \n            next: \"bad\",\n            // async predicate() {\n            // }\n        },\n        // [onEntry]() {  },\n    },\n    stateName2: {\n    }\n  })\n\n\n// usage: Create a state machine by using the GenericStateMachine's\n//     factory-method withDefinition({...machineStates}).\n//\n//  An oversimplified machine could look like this:\n//    const machineStates = {\n//      { green: { warnTraffic: \"yellow\" } },\n//      { yellow: { stopTraffic: \"red\" } },\n//      { red: { allowTraffic: \"green\", default: true } },\n//    }\n//\n//  This example could work in the real world, given another software module that decides\n//    when to trigger allowTraffic and the other transitions.  A version closer to realistic\n//    might look like this:\n//\n//    machineStates: {\n//      red: { default: true, onEntry() { return camera.enforceLaw() },\n//        allowTraffic: \"green\",\n//      },\n//      green: { onEntry() { return watchForCrossTraffic() },\n//        warnTraffic: { nextState: \"yellow\", effect() { return stopWatchingCrossTraffic() } }\n//      }\n//      yellow: { onEntry() { delayedRed() }\n//        stopTraffic: \"red\",\n//      }\n//    };\n//\n//  The states are defined as key/value pairs, where the key is the\n//     name of the state, and the value is an object having one\n//     or more transitions (defined below) and a few special keys:\n//\n//      * default: true        // makes it the default state; optional if there is a state named default\n//      * label: \"string\"      // gives a friendlier string, e.g. for onscreen display\n//      * onEntry: ‹function›  // called when the machine enters this state.  You can trigger\n//                             //  automatic transitions from this callback.\n//\n//   We recommend state names be clear, static-sounding words.  \"-ing\" and \"-ed\" words are typically good choices.\n//\n//   The transitions defined for each state are also key/values.  The keys are transition names; we recommend\n//      these sound like commands (\"start\", \"search\") or indications that something happened (\"opened\", \"thingAdded\").  \n//      Values can either be a simple string (the name of the next state resulting from this transition) or an object with \n//      nextState and optional callbacks for {predicate, effect}:\n//\n//      * nextState: string    // the next state that the machine will be in when this transition is triggered.\n//      * predicate: function  // if defined, it can allow or block the transition by returning true/false.\n//                             //   *** do not trigger transitions from this function.  Can be an async function.\n//      * effect: function     // if defined, this indicates a side-effect to be triggered before the machine\n//                             //   changes to nextState.\n//                             //   *** do not trigger transitions from this function.  Can be an async function.\n//      * reEntry: boolean     // for a transition that leads from the current state back to the same state, this\n//                             //   boolean attributes specifies that the `onEntry()` MUST be re-run.\n//\n//  All callbacks can be async functions, whose pending promises will block progress of the state machine.\n//\n//  Integration: A state machine class can also define an onTransition() method, useful for integrating the\n//    state-machine with an outside module (i.e. for reflecting the effect of the state having changed).  And a\n//    state-machine instance can further define a contextObject property, to which callbacks will be bound - as\n//    if those callbacks were defined in the contextObject's class.\n//\n//  Here's an other example showing all (??) of these together:\n//\n//  class MyStateMachine extends GenericStateMachine.withDefinition(\n//    {\n//      blocked: {\n//        label: \"--- pending host info ---\",\n//        default: true,\n//        detect: \"detecting\",\n//      },\n//      detecting: {\n//        onEntry() { this.installError = null },\n//        needsInstall: \"installing\",\n//        detectedLinux: \"preparingAccounts\",\n//        failed: \"failed\",\n//        rescan: { nextState: \"detecting\", reEntry: true }\n//      },\n//      preparingAccounts: {\n//        onEntry() { this.installError = null },\n//        success: \"done\",\n//        \"connectionFailed\": \"failed\",\n//      },\n//      \"preparingAccounts\": {\n//        async onEntry() {\n//          if (this.configurationSatisfied()) return this.transition('startConfiguring')\n//        },\n//        rescan: \"detecting\",\n//        startConfiguring: {\n//          predicate() { return this.configurationSatisfied() },\n//          nextState: \"configuring\",\n//        }\n//      }\n//    }\n//  ) { ... }\n//\nexport interface StateMachineArgs {\n    currentState: string;\n    contextObject?: any;\n    contextLabel: string;\n    logFacility? : string;\n    logProperties? : Object;\n    onTransition: Function; //!!! add more details to type\n}\n\nexport class StateMachineNext {\n    static UnmetPredicate = UnmetPredicate;\n    static InvalidTransition = InvalidTransition;\n\n    // currentState: string;\n    onTransition? : StateMachineArgs[\"onTransition\"]\n    contextObject: any;\n    contextLabel: string;\n    logFacility: string;\n    logProperties: Object;\n    recentGeneration: number;\n    asyncEnhancements? : any //!!! todo enhance this type\n\n    constructor({\n        currentState,\n        contextObject,\n        contextLabel,\n        logFacility,\n        logProperties = {},\n    }: StateMachineArgs) {\n        // TODO: test perf changes with these\n        //  //  this.currentState = currentState;\n        //  //  this._stateValues = null;\n        //  they should give better optimization opportunities to V8\n\n        this.contextObject = contextObject || this;\n        this.contextLabel = contextLabel;\n        this.logFacility = logFacility || \"stateMachine\";\n        this.logProperties = logProperties;\n        this.recentGeneration = 0;\n    }\n\n    static withDefinition<SM extends ValidMachineDef<SM>>(\n        machineDef: SM, name: string, options={}\n      ): typeof StateMachineNext {\n            //! it gives meaningful errors to javascript clients too:\n            if (!name)\n                throw new Error(\n                    `StateMachine.withDefinition(def, name): missing required 'name' of state-machine`\n                );\n            \n            let defaultState = \"default\" in machineDef && \"default\";\n            if (!defaultState) {\n                for (const [\n                    defaultStateName,\n                    { default: isDefault } ,\n                ] of Object.entries(machineDef) as any) {\n                    if (isDefault) {\n                        defaultState = defaultStateName;\n                        break;\n                    }\n                }\n            }\n            if (!defaultState)\n                throw new Error(`Each state machine requires a default state`);\n        \n\n    \n        const { asyncEnhancements:hasEnhs = undefined } = options as any; //!!! todo add type\n\n        const dynamicClass = class DefinedStateMachine extends StateMachineNext {\n            asyncEnhancements? = hasEnhs; //!!! todo enhance this type\n\n            constructor(args: StateMachineArgs) {\n                super(args)\n            }\n            //! it allows the definition to include options, which are transparently\n            //  available on the resulting state- machine class as a static member\n            static get options() {\n                return options;\n            }\n\n            static get displayName() {\n                return name;\n            }\n            get moniker() {\n                return name;\n            }\n\n            static get defaultState() {\n                return defaultState;\n            }\n            get defaultState() {\n                return defaultState;\n            }\n\n            static get def() {\n                throw new Error(\"where is this used?\");\n                return machineDef;\n            }\n            get def() {\n                if (this.asyncEnhancements && this.enhanced) return this.enhanced;\n                if (this._enhancing)\n                    throw new Error(\n                        `can't get def synchronously with a pending async enhancement`\n                    );\n                return machineDef;\n            }\n\n            delegateSetupTrigger(triggerFunction) {\n                if (this._enhancementTrigger) {\n                    debugger\n                    throw new Error(`can't set a second delegateSetupTrigger`)\n                }\n\n                const enhancementTrigger = (this._enhancementTrigger = async () => {\n                    const enhancements = await triggerFunction();\n                    return this.enhanceWith(enhancements);\n                });\n                return enhancementTrigger;\n            }\n\n            async enhanceWith(enhancementPromise) {\n                let enhanceDone, enhanceFailed;\n                this._enhancing = new Promise((res, rej) => {\n                    enhanceDone = res;\n                    enhanceFailed = rej;\n                });\n                const enhancement = await enhancementPromise;\n\n                const enhancing = cloneDeep(machineDef);\n                for (const [stateName, enhancementStateDef] of Object.entries(\n                    enhancement\n                )) {\n                    const origStateDef = machineDef[stateName];\n\n                    const label = `${this.moniker}@${stateName}`;\n                    if (!origStateDef) {\n                        enhancing[stateName] = enhancementStateDef;\n                        //!!! todo add logger\n                        // logger.progress(\n                        //     { summary: { label, stateDef } },\n                        //     \"enhanced with new state\"\n                        // );\n                        continue;\n                    }\n\n                    const enhancingThisState = enhancing[stateName];\n\n                    for (const [\n                        transName,\n                        enhancementTransDef,\n                    ] of Object.entries(enhancementStateDef)) {\n                        const origTransDef = origStateDef?.[transName];\n                        if (!origTransDef) {\n                            enhancingThisState[transName] = enhancementTransDef;\n                            //!!! todo add logger\n                            // console.warn(\n                            //     { summary: { label, stateDef, transName } },\n                            //     \"adding transition\"\n                            // );\n\n                            continue;\n                        }\n\n                        const enhancingThisTrans =\n                            enhancingThisState[transName];\n                        // at this point, this state existed already, and we have an enhancment to apply to it\n                        // if that enhancement is an onEntry hook...\n\n                        if (transName == \"onEntry\") {\n                            const { onEntry: origOnEntry } = origStateDef;\n\n                            //! it adds onEntry to an existing state not having one, if provided by the enhancement\n                            if (!origOnEntry) {\n                                enhancingThisState.onEntry =\n                                    enhancementTransDef;\n                                continue;\n                            }\n\n                            //! if the base machine has an onEntry() it chains the enhancement's onEntry() after it.\n                            const enhancedOnEntry = enhancementTransDef;\n                            const machine = this;\n                            enhancingThisState.onEntry = async function (\n                                machineArg\n                            ) {\n                                const { currentState: entryState } = machine;\n                                try {\n                                    await origOnEntry.apply(this, arguments);\n                                } catch (e) {\n                                    throw e;\n                                }\n\n                                //! it honors the priority of the base machine's onEntry(), if it transitions to a different state\n                                //    - and doesn't call the enhancement's onEntry()\n                                //    NOTE: if this is a problem, consider any pending use-cases in any proposed change.\n                                const nextState = machine.currentState;\n                                if (entryState == nextState) {\n                                    return enhancedOnEntry.apply(\n                                        this,\n                                        arguments\n                                    );\n                                } else {\n                                    // logger.progress({summary:{name: this.name, nextState}}, `baseline onEntry() asserted control over implicit transition to next state`)\n                                }\n                            };\n                            continue;\n                        }\n\n                        // At this point, the transition name existed already, and we have an enhancement to apply to it\n\n                        // console.warn( `merging transition '${transName}'`);\n\n                        const origNextState = nextState(origTransDef);\n                        const enhancedNextState =\n                            nextState(enhancementTransDef);\n                        //! doesn't allow override of the semantics of a transition by redirecting it to a different state.\n                        if (origNextState && enhancedNextState) {\n                            throw new Error(\n                                `Enhancement can't redirect an established transition to a different state: ${label}: ${transName} -> ${origNextState}`\n                            );\n                        }\n                        const enhancementPredicate =\n                            enhancementTransDef.predicate;\n                        if (enhancementPredicate) {\n                            if (!origTransDef.predicate) {\n                                enhancingThisTrans.predicate =\n                                    enhancementPredicate;\n                                continue;\n                            }\n                            enhancingThisTrans.predicate =\n                                async function composedPredicate(machine) {\n                                    try {\n                                        const result =\n                                            await origTransDef.predicate.call(\n                                                this,\n                                                machine\n                                            );\n                                        if (!result) return result;\n                                    } catch (e) {\n                                        throw e;\n                                    }\n                                    return enhancementPredicate.call(\n                                        this,\n                                        machine\n                                    );\n                                };\n                        }\n\n                        const enhancementEffect = enhancementTransDef.effect;\n                        if (enhancementEffect) {\n                            debugger;\n                            if (!origTransDef.effect) {\n                                enhancingThisTrans.effect = enhancementEffect;\n                                continue;\n                            }\n                            enhancingThisTrans.effect =\n                                async function composedEffects(machine: DefinedStateMachine) {\n                                    try {\n                                        await origTransDef.effect.call(\n                                            this,\n                                            machine\n                                        );\n                                        debugger;\n                                    } catch (e) {\n                                        //!!! todo use logger\n                                        const e2 = ZonedStackTrace.fromError(e);\n                                        console.warn(\n                                            `in state machine ${machine.moniker}: error  in base effect: `,\n                                            e2.stack()\n                                        );\n                                        console.warn(\n                                            `Continuing to execute stacked effect from delegate after base effect error in state machine ${machine.moniker}`\n                                        );\n                                    }\n                                    return enhancementEffect.call(\n                                        this,\n                                        machine\n                                    );\n                                };\n                        }\n                    }\n                }\n                let { currentState = this.defaultState } = this;\n\n                if (!enhancement[currentState]) {\n                    const fail = new ZonedStackTrace(\n                        `${this.moniker}: state ${currentState} is invalid`\n                    );\n                    const failedPromise = this._enhancing;\n                    this._enhancing = fail;\n                    enhanceFailed(fail);\n                    return failedPromise;\n                }\n\n                this._enhancing = undefined;\n                this._stateValues = undefined;\n                this.enhanced = enhancing;\n                enhanceDone(enhancement); // delayed resolution of promise for the enhancement\n                return enhancing;\n\n                function nextState(transDef) {\n                    return \"string\" === typeof transDef\n                        ? transDef\n                        : transDef.nextState;\n                }\n            }\n\n            get label() {\n                return `${this.moniker} @${this.currentState}`;\n            }\n        };\n        return dynamicClass\n    }\n\n    get stateValues() {\n        if (this._stateValues) return this._stateValues;\n        const labels = {};\n        for (const [statename, { label = statename }] of Object.entries(\n            this.def\n        )) {\n            if (\"apiActions\" === statename) continue;\n            labels[statename] = label;\n        }\n        return (this._stateValues = labels);\n    }\n    validateState(state) {\n        if (!state) return false;\n        const def = this.def;\n        if (def[state]) return state;\n        throw new Error(`invalid state ${state}`);\n    }\n    get currentState() {\n        throw new Error(\n            `currentState getter must be implemented by your State Machine subclass`\n        );\n    }\n    set currentState(newState) {\n        throw new Error(\n            `currentState setter must be implemented by your State Machine adapter`\n        );\n    }\n    hasEffectiveTransition(transitionName : string) {\n        // with modelStateMachine and apiActions(), this function avoids offering UI controls \n        //   for triggering actions that only re-enter same state.\n        //!!!! consider detecting these in terms of a \"no-op\" flag instead of checking for re-entry\n        return this.hasTransition(transitionName, effectiveTransOnly);\n    }\n    hasTransition(transitionName : string, requireEffectiveTransition? : typeof effectiveTransOnly) {\n        let { currentState = this.defaultState } = this;\n        let thisState = this.def[currentState] || this.def[this.defaultState];\n\n        let {\n            onEntry,\n            default: isDefaultState,\n            ...goodTransitions\n        } = thisState;\n\n        let transition = goodTransitions[transitionName];\n        if (typeof transition === \"string\")\n            transition = { nextState: transition };\n        if (transition && requireEffectiveTransition) {\n            if (transition.nextState == currentState && !transition.reEntry)\n                return false;\n        }\n        return !!transition;\n    }\n\n    nextState(transitionName : string) {\n        let { currentState = this.defaultState } = this;\n        let thisState = this.def[currentState] || this.def[this.defaultState];\n        let {\n            onEntry,\n            default: isDefaultState,\n            ...goodTransitions\n        } = thisState;\n\n        if (\"default\" == transitionName) {\n            if (isDefaultState || \"default\" == currentState) {\n                return currentState;\n            }\n        }\n\n        let transition = goodTransitions[transitionName];\n\n        if (typeof transition === \"string\")\n            transition = { nextState: transition };\n\n        let nextState =\n            (transition && transition.nextState) || \"‹undefined transition›\";\n\n        return nextState;\n    }\n    contextInfo() {\n        let { currentState = this.defaultState } = this;\n        return `🗜️${this.contextLabel} @${currentState}`;\n    }\n    transitionContextInfo(transitionName : string) {\n        return `${this.contextInfo()} transition ${transitionName}⭞ ${this.nextState(\n            transitionName\n        )}`;\n    }\n\n    async transition(transitionName : string) {\n        const location = new ZonedStackTrace();\n        const transitionContext = this.transitionContextInfo(transitionName);\n        let label = this.label || this.constructor.name;\n\n        if (this.asyncEnhancements) {\n            if (!this.enhanced) {\n                if (this._enhancing) {\n                    await this._enhancing;\n                } else if (this._enhancementTrigger) {\n                    debugger;\n                    await this._enhancementTrigger.call(this);\n                }\n\n                // this.enhanced isn't filled if there's no delegate record.\n                //   if (!this.enhanced) throw new Error(`enhanced should be filled after enhancements`);\n            }\n        }\n\n        const stateMachineName = `state-machine: ${label}`;\n\n        const logProps = {\n            transitionName,\n            ...this.logProperties,\n        };\n        const logLevel = this.def.logLevel;\n        if (logLevel) {\n            logProps.levels = {\n                [this.logFacility]: logLevel,\n                _message: `state-machine: ${this.name} definition`,\n            };\n        }\n        let transitionZone = forkZoneWithLogger(this.logFacility, logProps, {\n            name: stateMachineName,\n            properties: {\n                location,\n                addContext: transitionContext,\n            },\n        });\n        let logger = transitionZone.get(\"logger\");\n        return transitionZone.run(\n            this.transitionInZone.bind(this, transitionName)\n        );\n    }\n    async optionalTransition(transitionName: string) {\n        try {\n            const result = await this.transition(transitionName);\n            return result;\n        } catch (e:any) {\n            if (e instanceof UnmetPredicate) return false;\n            if (e instanceof InvalidTransition) return false;\n            console.warn(\n                \"optionalTransition: non-predicate error: \",\n                e.stack || e\n            );\n            //   Zone.current.get(\"logger\").warn({detail:{error: e.stack || e}}, \"optionalTransition: non-predicate error\")\n            throw e;\n        }\n    }\n    async transitionInZone(transitionName : string) {\n        let logger = Zone.current.get(\"logger\");\n\n        if (this._enhancing) await this._enhancing;\n\n        let { currentState = this.defaultState } = this;\n        let machineLabel = this.label || this.constructor.name;\n        let shortLabel = this.shortLabel || this.constructor.name;\n\n        let thisState = this.def[currentState];\n        if (!thisState)\n            throw new Error(\n                `${machineLabel}: bad current state ${currentState}`\n            );\n        let {\n            onEntry,\n            default: isDefaultState,\n            label,\n            ...goodTransitions\n        } = thisState;\n        const contextObject = this.contextObject || this;\n\n        let transition = goodTransitions[transitionName];\n\n        if (typeof transition === \"string\")\n            transition = { nextState: transition };\n        // const stateMachineName = `state-machine: ${machineLabel}`;\n\n        let nextState = this.nextState(transitionName),\n            isDefaultTransition;\n        if (\"default\" == transitionName) {\n            if (isDefaultState || \"default\" == currentState) {\n                isDefaultTransition = true;\n                transitionName = \"default-state onEntry\";\n            }\n        }\n\n        if (isDefaultTransition) {\n            const msg = `default transition`;\n            logger.progressInfo(\n                { detail: { transition: transitionName } },\n                msg\n            );\n            this.recentGeneration++;\n            if (onEntry) {\n                const zone = forkZoneWithContext(\n                    `🗜️${shortLabel} 🡆 ${transitionName} onEntry()`\n                );\n\n                this.needsDefaultTransition = undefined;\n                return zone.run(onEntry.bind(contextObject, this));\n            }\n            return;\n        }\n        if (this.needsDefaultTransition) {\n            const msg =\n                true === this.needsDefaultTransition\n                    ? \"\"\n                    : `(${this.needsDefaultTransition})`;\n\n            throw new ZonedStackTrace(\n                `${machineLabel}: has not run its defaultTransition yet ${msg}`\n            );\n        }\n\n        if (!transition) {\n            if (transitionName !== \"onUpdate\")\n                logger.progressInfo(\n                    {\n                        summary: `${machineLabel}: invalid: ${transitionName}`,\n                        detail: {\n                            transitionName,\n                            stack: new Error(\"called from\"),\n                        },\n                    },\n                    `throwing InvalidTransition`\n                );\n            //      debugger\n            throw new InvalidTransition(`${machineLabel}: INVALID transition('${transitionName}') from state '${currentState}' \n  (suggested: ${\n      Object.keys(goodTransitions).join(\",\") ||\n      \"‹none! this state appears to be terminal›\"\n  })}`);\n        }\n        let { predicate, effect, reEntry = false } = transition;\n\n        if (!transition.nextState)\n            throw new Error(\n                `${machineLabel}: INVALID transition definition '${transitionName}' from state '${currentState}'; should be string nextState or object {predicate,nextState,effect}`\n            );\n\n        const nextStateDef = this.def[nextState];\n\n        if (!nextStateDef) {\n            const msg = `${machineLabel}: INVALID target state in ${currentState}.transitions.${transitionName} -> state '${nextState}'`;\n\n            logger.error(\n                { detail: { currentState, transitionName, nextState } },\n                `invalid target state in transition definition`\n            );\n            const invalidTrans = new InvalidTransition(msg);\n            invalidTrans.stack =\n                invalidTrans.stack + \"\\n\" + Zone.current.get(\"location\").stack;\n            throw invalidTrans;\n        }\n        let pName = \"\";\n        if (predicate && \"predicate\" !== predicate.name) pName = predicate.name;\n\n        logger.progressInfo(\n            {\n                detail: { transitionName },\n                summary: `${this.label} ${transitionName} ${\n                    pName && `if(${pName}())`\n                }⭞ ${nextState}`,\n            },\n            `running transition`\n        );\n\n        if (predicate) {\n            if (typeof predicate !== \"function\")\n                throw new Error(\n                    `${machineLabel}: INVALID predicate (${predicate}); function required.\\n...in transition(${transitionName}) from state '${currentState}'`\n                );\n\n            const logProps = {\n                predicateName: pName || predicate.name\n            };\n\n            const predicateZone = forkZoneWithContext(\n                `${shortLabel} @${currentState}: ${transitionName}⭞: predicate ${pName}()`,\n                { logProps }\n            );\n            const predicateLogger = predicateZone.get(\"logger\");\n            const promise = predicateZone.run(predicate.bind(contextObject));\n            const predicateError = await hasError(promise);\n            if (predicateError) {\n                predicateLogger.error(\n                    {\n                        detail: {\n                            error: predicateError.stack || predicateError,\n                        },\n                    },\n                    `error thrown in transition predicate`\n                );\n                return promise;\n            }\n\n            const predicateResult = await promise;\n            if (\"undefined\" === typeof predicateResult) {\n                throw new Error(\n                    `${machineLabel}: INVALID predicate result (${predicateResult}) true/false required.\\n...in transition(${transitionName}) from state '${currentState}'`\n                );\n            }\n            if (predicateResult === false) {\n                const message = `${machineLabel}: ${currentState} ${pName}${\n                    pName && \"(🗙 )\"\n                } in ${transitionName}🗙 `;\n                predicateZone\n                    .get(\"logger\")\n                    .progressInfo(\n                        { summary: message },\n                        `predicate blocked transition`\n                    );\n                throw new UnmetPredicate(\n                    \"predicate blocked transition: \" + message\n                );\n            }\n        }\n\n        this.recentGeneration++;\n        const fromState = this.currentState.valueOf();\n        this.currentState = nextState;\n\n        if (effect) {\n            const zone = forkZoneWithContext(\n                `🗜️: ... ${transitionName}⭞ effect() 🡆 ${nextState}`\n            );\n            try {\n                await zone.run(effect.bind(contextObject, this));\n            } catch (e: any) {\n                e.message =\n                    `${machineLabel}: <-!${transitionName}⭞ error in effect callback:\\n` +\n                    (e.message || e);\n                zone.get(\"logger\").warn(\n                    { detail: { error: e.message || e } },\n                    `error in effect callback`\n                );\n                throw e;\n            }\n        }\n        if (nextStateDef.onEntry) {\n            const changedState = fromState !== nextState.valueOf();\n\n            if (changedState || reEntry) {\n                const zone = forkZoneWithContext(\n                    `🗜️${shortLabel} 🡆 ${nextState} onEntry()`\n                );\n\n                await zone.runWithWarnings(\n                    nextStateDef.onEntry.bind(contextObject, this)\n                );\n            } else {\n                logger.debug(`🡆 ${nextState} has no defined onEntry`);\n            }\n        }\n\n        if (this.currentState != nextState) {\n            logger.consoleInfo(\n                {\n                    summary:\n                        `${machineLabel} ${pName}${pName && \"(🗸) \"}🡆 ` +\n                        `${nextState}:onEntry 🡆 ${this.currentState}`,\n                },\n                \"  🗸 trampolined \"\n            );\n            // because it already transitioned to another state,\n            // we don't need to trigger the onTransition again.\n            if (this.onTransition)\n                logger.progressInfo(\n                    {\n                        summary: machineLabel,\n                    },\n                    \"      onTransition notification already pending\"\n                );\n\n            return;\n        }\n        //! uses a freshened machineLabel if the transition causes it to change\n        //   XXX didn't work for model's state-machine : (\n        //   machineLabel = this.label || this.constructor.name\n\n        //no further transition during the onEntry\n        logger.consoleInfo(\n            {\n                summary: `${machineLabel} ${pName}${\n                    pName && \"(🗸) \"\n                }🡆 ${nextState}`,\n            },\n            \"  🗸 transitioned\"\n        );\n\n        if (this.onTransition) {\n            const integrationHookZone = forkZoneWithContext(\"onTransition\");\n\n            const { recentGeneration } = this;\n\n            const result = await integrationHookZone.run(\n                this.onTransition.bind(contextObject, {\n                    transitionName,\n                    currentState,\n                    fromState,\n                    recentGeneration,\n                    logger: integrationHookZone.get(\"logger\"),\n                })\n            );\n            return result;\n        }\n    }\n}\n\n","/home/san/dev/poshplum-next/packages/utils/src/asyncDelay.js",[],[],"/home/san/dev/poshplum-next/packages/utils/src/asyncSingletonMethod.js",["539","540","541"],[],"// collects any number of pending async callers, executes the function,\n// and returns the result to all of the callers at the same time (actually\n// returns one promise to each of them separately, and resolves that promise\n// a single time)\n//\n// assists the singleton in cutting over between this call and next-call\n// by providing a `releaseMe` function to the method implementation; this\n// lets the implementation imperatively wait for additional callers, debouncing\n// and coalescing their requests, then releasing the singleton block, which\n// lets future callers start a fresh batch (with a fresh promise) while the\n// first batch of requests finishes and resolves the initial single promise.\n// The initial promise is remembered as a \"ghost\"; see below.\n//\n// When releaseMe() is used, a second batch of singleton callers is blocked\n// until the prior batch (the ghost) is completed, thus serializing the calls.\n// Possibly this should be an option, allowing separate batches to make progress\n// at the same time.  If so, it may also be appropriate to store an index of\n// these \"ghost\" instances for troubleshooting purposes - that, or to remove the\n// ghosts entirely, to be sure we aren't causing memory leaks.\n//\n// If releaseMe is not called (or not used) by the singleton method, it is\n// automatically resolved.  In this mode, callers 1..n all receive the single\n// result from the first caller, and the next caller (n+1) will get a new\n// promise and the singleton method will execute and resolve that new promise\n// separately.\n//\n//\n// Usage:\n//   class Foo {\n//     async fetchMyStuff() {  // simple implementation\n//       return asyncSingletonMethod(this, \"fetchMyStuff\", async() => {\n//         return fetch(\"/something\")\n//       })\n//     }\n//     async fetchOtherStuff(something) { // debounce + accumulate requests\n//       this.stuff = this.stuff || []\n//       this.stuff.push(something)\n//       return asyncSingletonMethod(this, \"fetchOtherStuff\", async(release) => {\n//         await delay(3);  // accumulate stuff from other calls to fetchOtherStuff\n//         release()\n//         const accumulatedStuff = this.stuff;\n//         this.stuff = []; // let other stuff start accumulating\n//         return fetch(\"/getStuff\", {method:\"post\", body: JSON.stringify(accumulatedStuff), {headers: {accept:\"application/json\"}}})\n//       })\n//     }\n//   }\n\nexport async function asyncSingletonMethod(ctx, name, fn) {\n    ctx.aSing = ctx.aSing || { _gh: {} };\n    let anotherCallToMe = ctx.aSing[name];\n    if (anotherCallToMe) {\n        // console.error(`aSing ${name} will return result of already-pending call.`)\n        return await anotherCallToMe;\n    }\n\n    // this serializes potentially-overlapping calls to the method\n    // that can happen when releaseMe() is called within the function\n    let myGhost = ctx.aSing._gh[name];\n    if (myGhost) {\n        // console.error(`aSing ${name} waiting for my ghost`)\n        await myGhost.catch((e) => {\n            console.error(\n                `aSing ${name} my ghost had an error.  That's probably bad!`\n            );\n        });\n        // console.error(`aSing ${name} ok, my ghost is done`)\n        delete ctx.aSing._gh[name];\n    }\n    let released = false;\n    const myself = (ctx.aSing[name] = new Promise((res, rej) => {\n        // console.error(`aSing ${name} calling through`)\n        fn(releaseMe).then(res, rej);\n    }));\n    let resolved;\n    let result, error;\n    try {\n        result = await myself;\n    } catch (e) {\n        error = e;\n    }\n    resolved = true;\n    function releaseMe() {\n        released = true;\n        if (!resolved) ctx.aSing._gh[name] = myself;\n        delete ctx.aSing[name];\n    }\n    if (!released) releaseMe();\n\n    // let the caller's own error-handling prevail, returning a failed-promise\n    //   in preference over directly throwing.\n    return error ? myself : result;\n}\n","/home/san/dev/poshplum-next/packages/utils/src/emailRegex.js",["542","543","544","545","546","547","548","549"],[],"// from https://emailregex.com/\nexport const EMAIL_REGEX =\n    /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n","/home/san/dev/poshplum-next/packages/utils/src/ensureProtoChainProp.js",["550"],[],"/home/san/dev/poshplum-next/packages/utils/src/hasError.js",["551","552"],[],"import { contextLogger } from \"./zonedLogger\";\n\nexport function fixupFailure(failure) {\n    if (!failure.reason) {\n        if (failure.status) {\n            failure.code = failure.status;\n            delete failure.status;\n\n            failure.reason = failure.message;\n            delete failure.message;\n\n            failure.error = failure.name;\n            delete failure.name;\n\n            return failure;\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            failure.reason = failure.message || failure.stack;\n            failure.error = \"internal server error\";\n            failure.stack = failure.stack;\n            failure.code = 500;\n        }\n    }\n    return failure;\n}\n\nexport async function hasError(promise) {\n    try {\n        // console.error(\"hasError awaiting promise\", promise)\n        let result = await promise;\n        if (isError(result)) {\n            // debug(\"<- hasError: true (non-thrown error)\", result);\n            return fixupFailure(result);\n        }\n        // debug(\"<- hasError: false\");\n        // console.error(\"hasError? seems good:\", result)\n        return false;\n    } catch (err) {\n        if (isError(err)) {\n            // debug(\"<- hasError: true\", err);\n            return fixupFailure(err);\n        } else {\n            contextLogger(\"api:access\").warn(\n                \"<- hasError: unexpected error type\",\n                err\n            );\n\n            return false;\n        }\n    }\n}\nexport function isError(err) {\n    if (err && \"function\" === typeof err.isError) return err.isError();\n    if (err && (!!err.error || !!err.message || err instanceof Error))\n        return true;\n    if (err && err.reason)\n        throw new Error(\n            `after changing to using isError() detection, err.reason isn't enough to imply error - hoping for 'message' or 'error' attribute instead`\n        );\n}\n","/home/san/dev/poshplum-next/packages/utils/src/index-browser.ts",[],[],"/home/san/dev/poshplum-next/packages/utils/src/index.ts",[],[],"/home/san/dev/poshplum-next/packages/utils/src/misc.js",["553","554","555","556"],[],"import {__decorate} from 'tslib';\n\nexport function text2list([text], ...badArgs) {\n    if (badArgs.length) throw new Error(\"text2list can't take interpolations\");\n    return text\n        .split(\"\\n\")\n        .map((line) => line.trim())\n        .filter((line) => !!line);\n}\n\nexport function text2map(text) {\n    const array = text2list(text);\n    const map = {};\n    for (const item of array) {\n        let [val, labelInfo = val] = item.split(/:/, 2);\n        labelInfo = labelInfo.replace(/^\\+/, val + \" \");\n\n        map[val] = labelInfo;\n    }\n    return map;\n}\n\n\nexport function autobindMethods(clazz, methods = clazz.autobindMethods) {\n    if (!methods?.length) throw new Error(`usage: autobindMethods(class, [...methods: string]).  class may define static autobindMethods instead of passing an array of method names`)\n\n    for ( const m of methods) {\n        if (!clazz.prototype[m]) {\n            console.warn(`autobindMethods: skipping unknown method '${m}' in class '${clazz.displayName}'`);\n            continue\n        }\n\n        __decorate([ autobind ], clazz.prototype, m, null);        \n    }\n    return clazz\n}\n\nexport function autobind(proto, name, descriptor) {\n    let func = descriptor.value;\n\n    if (\"function\" !== typeof func) {\n        throw new TypeError(`@autobind must only be used on instance methods`);\n    }\n\n    //! it configures the named property to use just-in-time binding\n    return {\n        configurable: true,\n        get() {\n            const bound = func.bind(this);\n            bound.innerFunction = func;\n            //! just-in-time, it reconfigures the property to statically return the bound function\n            Object.defineProperty(this, name, {\n                configurable: false,\n                get() {\n                    return bound;\n                },\n            });\n            return bound;\n        },\n    };\n}\n\nexport function withPrototype({ ...props }) {\n    return (clazz) => {\n        Object.assign(clazz.prototype, props);\n        return clazz;\n    };\n}\n\nexport function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n        obj[key] = val;\n        return obj;\n    }, {});\n}\n\nexport function enumeratedMap(proto, name, { methods = {}, ...descriptor }) {\n    const enumName = `${proto.name}.${name}`; // works for static class variables; adjust if needed later.\n    const obj = descriptor.initializer();\n    if (\"object\" !== typeof obj)\n        throw new Error(\n            `no support (yet) for this kind of EnumeratedMap (for '${name}')`\n        );\n\n    const internalMap = new Map(Object.entries(obj));\n    const invertedEntries = [...internalMap.entries()].map(([k, v]) => [v, k]);\n    const alreadyInverted = fromEntries(invertedEntries);\n    const inverted = () => alreadyInverted;\n\n    descriptor.initializer = () => {\n        return new Proxy(internalMap, {\n            get(target, k, receiver) {\n                if (k == \"entries\") return () => internalMap.entries();\n                if (k == \"invertedEntries\") return invertedEntries;\n                if (k == \"inverted\") return inverted;\n                const v = internalMap.get(k);\n                if (v) return v;\n\n                if (methods[k]) return methods[k].bind(receiver);\n                if (!v && !internalMap.has(k))\n                    throw new Error(`invalid key '${k}' for ${enumName}`);\n\n                return v;\n            },\n        });\n    };\n    return descriptor;\n}\n\nenumeratedMap.withMethods =\n    ({ ...methods }) =>\n    (proto, name, descriptor) => {\n        return enumeratedMap(proto, name, {\n            methods,\n            ...descriptor,\n        });\n    };\n\nexport function sumObject(keys, values, rereduce) {\n    if (rereduce) {\n        throw new Error(\n            `wow, pouchdb started calling with rereduce.  FIXME.  Also, check object _sum support`\n        );\n    }\n    const reduced = {};\n    for (const oneV of values) {\n        for (let [k, v] of Object.entries(oneV)) {\n            if (\"object\" === typeof v)\n                throw new Error(\n                    `sorry, nested objects not supported by this test-time shim. :(`\n                );\n            if (\"undefined\" === typeof v) v = 0;\n            if (\"number\" !== typeof v)\n                throw new Error(\n                    `object values must be numbers :( got ${k}=${JSON.stringify(\n                        v\n                    )} ):`\n                );\n            reduced[k] = (reduced[k] || 0) + parseFloat(v);\n        }\n    }\n\n    return reduced;\n}\n","/home/san/dev/poshplum-next/packages/utils/src/timeAgo.js",[],[],"/home/san/dev/poshplum-next/packages/utils/src/zonedLogger.js",["557","558","559","560","561","562","563","564","565","566","567","568","569","570","571","572","573","574","575","576","577","578","579","580","581","582","583","584","585","586","587","588","589","590","591","592","593","594","595","596","597","598","599","600","601"],[],"import chalk from \"chalk\";\nimport createLogger from \"pino\";\n\nimport * as nothing from  \"zoned-cls\";//dist/zoned-cls.js\";\nif (42 < 41) nothing;\n\n// import nothingElse from 'zoned-cls/dist/long-stack-trace-zone';\nimport { child_process } from \"@platform/child_process\";\nimport { os } from \"@platform/os\";\nimport { logDestination } from \"@platform/logDestination\";\nconst {localEnv} = logDestination;\n\nimport { hasStdOut } from \"@platform/stdout\";\n\nconst OPS_LEVEL =\n    ((\"undefined\" !== typeof process) && process.env.OPS_LEVEL && parseInt(process.env.OPS_LEVEL)) ||\n    (\"production\" === process.env.NODE_ENV && 45) ||\n    28;\nconst USER_ERROR_LEVEL = (\"development\" !== process.env.NODE_ENV && 32) || 42;\n\nconst usage1 = `usage: zonedLogger(loggerName, {...logDetails}) \n\nReturns a logger derived from the current zone.  With no arguments,\nit simply returns the current zone's logger as-is.  \n\nWhen one or 2 arguments are provided, it uses the zone's logger to\ncreate a child logger with the indicated log-facility. Any provided \nlogDetails are added to the new logger and will be included with \nall the log entries.  The 'pino' library is used for the logger object.\n\nThe current zone's baseLogLevels and localLogLevels are consulted\nto determine the level of logging is enabled for the child logger \n(localLogLevels takes precedent over baseLogLevels).  \n\nIf the log-facility doesn't have an explicit log-level set in these \nplaces, then 'default' is looked up in the same way to determine the \neffective log level (this is 'warn' by default, but can be overridden \nwith the LOGGING key in process.ENV or, in browser, localStorage).\n\nWith zonedLogger(), no zone-fork is done, and no future zone-forks \nwill inherit this child logger or its logDetails. Use forkZoneWithLogger() \nto make a new zone AND logger.\n`;\n// no need to show this in external docs:\n// The third argument is only needed for the initial call, and that call\n// is normally done by forkZoneWithLogger() - it's recommended to use it\n// to initialize zoned logging.\n\n// default level numbers from pino:\n//\n//   trace: 10,\n//   debug: 20,\n//   info: 30,\n//   warn: 40,\n//   error: 50,\n//   fatal: 60\n\nconst usage2 = `usage: forkZoneWithLogger(loggerName, logProps: {\n        levels: object (optional),\n        addContext: string (recommended),\n        ...logDetails\n    }, zoneSettings: {\n      name: zoneName, \n      ...zoneSpecs\n    })\n\nCreates a new child logger with the indicated logger name, forks\n    a new zone with the indicated zone details, and returns the forked\n    zone with the logger set in the zone's context properties.  Within\n    functions executed in that zone, you can call zonedLogger() to fetch\n    or derive a logger object.  \n    \nThe parent logger is taken from Zone.current.get(\"logger\").  For the \n    first, top-level call to forkZoneWithLogger, the logger is created \n    with default-log-levels taken from ENV.LOGGING \n    or localStorage.getItem('LOGGING'). \n\nThe 'pino' library is used for the logger object.  All other conventions \n    provided by pino behave as indicated by that library.\n    \nSome custom log levels are included in the logger: 'progress' is designed\n    to give visibility over the flow of execution without excessive \n    details; its numeric level of 25 is more detailed than 'info' but \n    less than 'debug'.  'userError', normally* at level 32, is more detailed \n    than 'error' but less than 'info'.  'ops', normally* at level 45, is\n    intended for logging operational metrics.  The resulting enhanced \n    hiearchy of log levels, in INCREASING order of detail and DECREASING \n    order of their severity values, is (in production) as follows:\n    \n      fatal=60, error=50, ops=45, warn=40 (DEFAULT), \n          userError=32, info=30, progress=25, debug=20, trace=10\n          \n    By placing userError at higher severity than 'info', even the most\n    cursory investigations at log-level=info will reveal any events\n    in production that are attributable to \"user error\".  \n    \n    When userError events are generated in an API call, it is the API \n    client considered as \"the user\" here.  UI application code may \n    actually be at fault, but that consideration is outside the scope of \n    zonedLogger's visibility.\n\n    * Note that when NODE_ENV is 'development',\n    the numeric values of 'ops' and 'userError' are adjusted so that\n    ops metrics don't cause distractions, and so that userError events\n    are raised by default, similar to warnings for development-time\n    transparency. The resulting hierarchy in development is as follows:\n    \n      fatal=60, error=50, userError=42, warn=40 (DEFAULT), \n          info=30, ops=28, progress=25, debug=20, trace=10\n\n    Adjusting 'ops' severity in this way also allows developers to easily \n    validate ops events without needing to see 'progress' (use LOGGING=default:ops).\n    \n    ** In the \"test\" environment, userError has the same priority as it does \n    in production, so that tests for user-caused problems like an API call \n    that returns a 400-series response don't cause log noise.  \n    Use LOGGING=‹facility›:info (or :userError) to show those events.  \n    ops is at level 28 in test, just as it is in development: \n\n      fatal=60, error=50, warn=40 (DEFAULT), \n          userError=32, info=30, ops=28, progress=25, debug=20, trace=10\n\n \nAny logDetails are added to the new logger, to be included with any \n    entries logged.  Any levels indicated can override \"up-fork\" levels \n    to increase logging details from the indicated log facilities.\n    These overrides can't suppress details such as 'fatal' or 'warn', \n    or any other details implied by the default-log-levels configured \n    as described above.  \n\nWhen new levels are provided, those levels are merged with the mentioned\n    \"up-fork\" levels, and these merged levels are used to determine the\n    effective logging level for the the provided loggerName.\n    \n      forkZoneWithLogger(\"myGoodLog\", {levels:{myGoodLog: \"progress\"}})\n\n‹levels› can be a string of \"log:facility:‹level›,other:facility,...\".  \n    If a ‹level› is not provided on one of these, \"info\" is implied.\n‹levels› can be an object of { \"‹facility›\": ‹level›|null|true }, \n    where a ‹level› of  null or \"true\" implies \"info\" level.\n‹levels› cannot reduce the log level for any facility below the levels \n    indicated in the global logging config.\nIf ‹levels› has a \"_message\" key, the string in that key is emitted \n    with a \"▒▒▒▒ log override ▒▒▒▒\" warning message in the log, \n    which can ease back-tracking any log overrides that have been \n    configured.  When implementing a property-based logLevel= \n    configuration, such as in a model-indexing configuration, this\n    technique is important to guide a developer to the place where\n    their override is actually specified, instead of to the line of code\n    that actually provides ‹levels› to any of the functions in this module.\n    \nThe new zone is created with the indicated name, using the zoneSpecs \n    provided, and with the logger assigned to the zone's 'logger' property.\n    To include additional properties in the forked zone, use the \n    'properties' entry in the zoneSpecs.\n    \nThe function indicated in ‹run› or ‹runGuarded› in the forked zone is \n    called, and the result is returned to the caller.  If ‹run› or   \n    \nIf ‹wrap› is specified instead, then the zone-wrapped function is simply\n    wrapped and returned without being called.\n\n`;\n\nlet logDest = logDestination();\n\nconst consoleLogging = !!parseInt(localEnv(\"CONSOLE_LOGGING\"));\nconst toConsoleOnly = \"42\" === localEnv(\"CONSOLE_LOGGING\");\n\nconst boundConsoleMethods = {\n    log: console.log.bind(console),\n    info: console.info.bind(console),\n    warn: console.warn.bind(console),\n    error: console.error.bind(console),\n    debug: console.debug.bind(console),\n};\n\nfunction consoleActivity(\n    {\n        color,\n        level,\n        bg,\n        withDetail = true,\n        method = \"log\",\n        icon = \"\",\n        indent = \"\",\n    },\n    ...args\n) {\n    if (!consoleLogging) return;\n\n    const extraAttrs = \"object\" === typeof args[0] ? args.shift() : {};\n    let { detail, summary, icon: loggedIcon } = extraAttrs;\n    if (loggedIcon) icon = loggedIcon;\n    if (level && this.isLevelEnabled(level) && withDetail && detail)\n        summary = null;\n    let message = args.shift();\n\n    if (indent) message = `${indent}${message}`;\n    const [_, indented, pureMessage] = message.match(/^( *)(.*)/s);\n    const indentString = \"  \" + indented;\n    message = `${indented}${icon}${pureMessage}`;\n\n    if (color) {\n        if (child_process) {\n            message = color(message);\n        } else {\n            message = \"%c\" + message;\n            args.unshift(color);\n        }\n    }\n\n    if (withDetail && detail) {\n        args.push(detail);\n        summary = null;\n    }\n    if (summary) {\n        if (\"function\" == typeof summary) summary = summary();\n        if (\"object\" == typeof summary) summary = JSON.stringify(summary);\n        if (child_process) {\n            message = `${message} ${chalk.blueBright(summary)}`;\n        } else {\n            message = `${message}%c ${summary}`;\n            args.unshift(\"color:#01efef\");\n        }\n    }\n    if (withDetail && !summary) {\n        let { chindings } = this;\n        let objects = chindings ? [chindings] : [];\n\n        let parent = Object.getPrototypeOf(this);\n        while (parent && parent.chindings) {\n            objects.unshift(parent.chindings);\n            parent = Object.getPrototypeOf(parent);\n        }\n        if (objects.length) {\n            let moreDetail = {};\n            for (detail of objects.reverse()) {\n                if (detail.processName) continue;\n                moreDetail = { ...moreDetail, ...detail };\n            }\n            delete moreDetail.context;\n            if (Object.keys(moreDetail).length) args.push(moreDetail);\n        }\n    }\n\n    if (child_process) {\n        message = `${message} ${bg(\" \" + this.loggerName + \" \")}`;\n    } else {\n        message = `${message} %c${this.loggerName}`;\n        child_process && args.unshift(bg);\n    }\n\n    if (!method) debugger;\n    if (!boundConsoleMethods[method]) debugger;\n    if (hasStdOut) {\n        hasStdOut([\n            message,\n            \" \",\n            ...args\n                .map((a) => {\n                    if (\"string\" === typeof a) return chalk.blueBright(a);\n                    if (\"undefined\" === typeof a)\n                        return chalk.blueBright(\"‹undefined›\");\n                    const shorty = JSON.stringify(a);\n                    if (shorty.length < 160) return chalk.blueBright(shorty);\n                    return JSON.stringify(a, null, indentString);\n                })\n                .join(\" \"),\n        ]);\n\n        return;\n    }\n    return boundConsoleMethods[method](message, ...args);\n}\n\nfunction consoleOnly(...args) {\n    if (!consoleLogging) return;\n\n    this.consoleActivity(\n        {\n            color: chalk.blue,\n            bg: chalk.black.bgBlueBright,\n        },\n        ...args\n    );\n}\n\nfunction noConsoleError() {\n    throw new Error(\n        `there is no consoleError method - use logger.error() or logger.consoleWarn()`\n    );\n}\n\nfunction consoleInfo(...args) {\n    if (child_process) {\n        if (!toConsoleOnly) this.info(...args);\n    } else {\n        return browserLogWriter.write.info.call(this, ...args);\n    }\n    if (!consoleLogging) return;\n\n    const withDetail = this.isLevelEnabled(\"progress\");\n    this.consoleActivity(\n        {\n            level: \"info\",\n            withDetail,\n            method: \"log\", // in firefox Developer Tools, this is distinguishably less info than progress@info level is.\n            color: child_process ? chalk.green : \"color:#f99\",\n            bg: child_process\n                ? chalk.bgGreen.black\n                : \"background:#f99;color:#black\",\n        },\n        ...args\n    );\n}\n\n// function logLandmark(id, {...details}, message) {\n//     // ...notify test observer\n// }\n//\n// function mockPointLog(id, {...details}, message) {\n// }\n//\n// function mockPoint(id) {\n//     return function(decoratedMethod) {\n//         return function(...args) {\n//           const {mockPredicate, mockValue} = logObserver.hasMockFor(id);\n//               if (mockPredicate && mockPredicate(...args)) { ... }\n//                   if (mockValue) { return mockValue };\n//             decoratedMethod(...args)\n//         }\n//     }\n// }\n//\n// @mockPoint(\"abc123\")\n// function foo(...args) {\n//\n// }\n//\n// function doSomeTest() {\n//     logObserver.addMock(\"abc123\", {mockPredicate({url}) { return true if \"/user/42\" == url }, mockValue: {name: \"joe\"} })\n//\n//       ...\n// }\n\nfunction consoleProgress(...args) {\n    if (child_process) {\n        if (!toConsoleOnly) this.progress(...args);\n    } else {\n        return browserLogWriter.write.progress.call(this, ...args);\n    }\n    if (!consoleLogging) return;\n\n    const withDetail = this.isLevelEnabled(\"debug\");\n\n    this.consoleActivity(\n        {\n            level: \"progress\",\n            withDetail,\n            color: child_process ? chalk.magentaBright : \"color:#f6e\",\n            bg: child_process\n                ? chalk.bgMagentaBright.black\n                : \"background: #f6e;color:black\",\n            method: \"info\", // lets more serious \"debug\" messages,\n            // from logger.debug(), be filtered out in Chrome dev tools\n            //   while the color and indent distinguish these in-between messages\n            // FF developer tools can just filter the \"info\" level directly (= progress+consoleProgress)\n            indent: \"  \",\n        },\n        ...args\n    );\n}\n\nfunction consoleWarn(...args) {\n    if (!child_process) {\n        return browserLogWriter.write.info.call(this, ...args);\n    } else {\n        if (!toConsoleOnly) this.warn(...args);\n    }\n    if (!consoleLogging) return;\n\n    this.consoleActivity(\n        {\n            color: child_process ? chalk.yellowBright : \"color:#ffc\",\n            bg: child_process\n                ? chalk.bgYellowBright.black\n                : \"background: #ffc;color:black\",\n            withDetail: true,\n            level: \"info\", // this is a convenient lie, allowing {summary} to be emitted unless a higher log level is enabled,\n            //  (because `warn` is ALWAYS enabled)\n\n            method: \"warn\", // lets more serious \"debug\" messages,\n            // from logger.debug(), be filtered out in Chrome dev tools\n            //   while the color and indent distinguish these in-between messages\n            // FF developer tools can just filter the \"info\" level directly (= progress+consoleProgress)\n            icon: \"⚠ \",\n        },\n        ...args\n    );\n}\n\n// logs console messages (or 'progress' log events) exactly like consoleProgress,\n// except only if 'info' level has been requested.  This provides a good middle\n// ground for diagnostics:\n//   * allows progress to be displayed conditionally (instead of\n//     unconditionally with consoleProgress)\n//   * but in a distinctive way from info, with implicit indentation\n//     for the console output\n//   * when 'progress' level is enabled and console-logging is disabled,\n//     this is just emitted as a progress event.\nfunction progressInfo(...args) {\n    if (this.isLevelEnabled(\"info\")) {\n        if (child_process) {\n            if (!toConsoleOnly) return this.progress(...args);\n            this.consoleProgress(...args);\n        } else {\n            return browserLogWriter.write.progressInfo.call(this, ...args);\n        }\n    \n        // consoleProgress does emit this.progress(...) ALSO.\n        // vvvv   hence the else\n    } else {\n        this.progress(...args);\n    }\n}\n\nfunction bannerInfo(msg) {\n    this.consoleInfo(\n        chalk.bgBlue.bold.black(\n            \"                            ===============================================\\n\" +\n                `                            =================== ${msg}  \\n` +\n                \"                            ===============================================\"\n        )\n    );\n}\n\nconst browserTransport = {};\nfunction browserConsoleLogger(\n    defaultConsoleMethod,\n    options={}\n) {\n    const {\n        icon = \"\",\n        postIcon = \"\",\n        style,\n        indent=\"\",\n        detail: withDetail=true\n    } = options;\n\n    defaultConsoleMethod = browserConsoleLogger._methods[defaultConsoleMethod] =\n        browserConsoleLogger._methods[defaultConsoleMethod] ||\n        console[defaultConsoleMethod].bind(console);\n\n    return function (...args) {\n        const extraAttrs =\n            \"object\" === typeof args[0] && (args[0].detail || args[0].summary)\n                ? args.shift()\n                : {};\n        let { \n            detail, summary,\n            consoleMethod : cmOverride,\n            indent: space=indent,\n         } = extraAttrs;\n         \n         let message = \"string\" === typeof args[0] ? args.shift() : \"\";\n         let [...rest] = args;\n\n         let consoleMethod = cmOverride ? (\n            browserConsoleLogger._methods[cmOverride] =\n                browserConsoleLogger._methods[cmOverride] ||\n                console[cmOverride].bind(console)\n         ) : defaultConsoleMethod\n\n         let { chindings } = this;\n\n        let objects = chindings ? [chindings] : [];\n        let parent = Object.getPrototypeOf(this);\n        while (parent && parent.chindings) {\n            objects.unshift(parent.chindings);\n            parent = Object.getPrototypeOf(parent);\n        }\n\n        if (withDetail) {\n            if (detail) {\n                objects.unshift(detail);\n            } else if (summary) objects.unshift(summary);\n        } else {\n            if (summary) {\n                objects.unshift(summary);\n            } else if (detail) objects.unshift(detail);\n        }\n\n        if (style) {\n            message = `%c ${message}`;\n            rest.unshift(style);\n        }\n        rest.unshift(\n            \"margin:-0.1em 0 -0.2em 0;font-size:80%;\" +\n                \"display:inline-block;vertical-align:top;background-color:#333;\" +\n                \"border:1px solid #333;color:#999;padding:2px;border-radius:3px;min-width:25ch\",\n            \"noStyle\"\n        );\n        return consoleMethod(\n            `${space}%c${icon || \" \"}${this.loggerName} ${postIcon}%c ${message || \"\"}`,\n            ...rest,\n            ...objects\n        );\n    };\n}\nbrowserConsoleLogger._methods = {};\n\nconst browserLogWriter = {\n    write: {\n        noop() {},\n        progress: browserConsoleLogger(\"info\",\n            { icon: \"📍 \", style: \"color: #f6e\", detail: true}),\n        progressInfo: browserConsoleLogger(\"debug\", {\n             indent: \"    \", icon:\"📍 \", postIcon: \"ℹ️\", style: \"color: #f6e\"}),\n        info: browserConsoleLogger(\"info\", {\n            icon: \"ℹ️ \", style:\"color: #aaf\"\n        }),\n        ops: browserConsoleLogger(\"debug\", {icon: \"⏱️ \", detail: true}),\n        userError: browserConsoleLogger(\"error\", {}),\n        warn: browserConsoleLogger(\"warn\", {detail: true}),\n        error: browserConsoleLogger(\"error\", {detail: true}),\n        debug: browserConsoleLogger(\"debug\", {\n            indent: \"   \", style: \"color: #99f\", detail: true\n        }),\n    },\n};\n\n// pretty-print automatically in browser.\n// NOTE: For server-side, dev-time pretty-logging,\n// pipe development servers to `yarn prettyLog`, the way the `devServer` script does\nconst prettyPrint = child_process\n    ? null\n    : {\n          levelFirst: true,\n          ignore: \"hostname,pid\",\n          translateTime: \"SYS:HH:MM:ss.l\",\n      };\nconst essentialLogSettings = {\n    //  nestedKey: \"d\",  // doesn't work on base log attributes;\n    //     (only applies to attrs in log calls like logger.<logLevel>({attrs}, \"message\") )\n\n    customLevels: {\n        ops: OPS_LEVEL,\n        userError: USER_ERROR_LEVEL,\n        progress: 25,\n    },\n    // useLevelLabels: true,\n    prettyPrint,\n    base: child_process\n        ? {\n              env: process.env.NODE_ENV || \"development\",\n              pid: process.pid,\n              hostname: os.hostname(),\n              type: \"log\",\n          }\n        : {\n              type: \"log\",\n              env: \"browser\",\n          },\n    ...(child_process\n        ? {}\n        : {\n              browser: {\n                  asObject: true,\n                  ...browserLogWriter,\n                  ...browserTransport,\n              },\n          }),\n};\n\nconst rootLogger = createLogger(\n    { name: \"root\", ...essentialLogSettings },\n    logDest\n);\n\nif (!rootLogger.userError || !rootLogger.levels.values.userError) {\n    rootLogger.levels.values[\"userError\"] = USER_ERROR_LEVEL;\n    rootLogger.levels.labels[`${USER_ERROR_LEVEL}`] = \"userError\";\n    rootLogger.userError = rootLogger.error;\n}\nif (!rootLogger.ops || !rootLogger.levels.values.ops) {\n    rootLogger.levels.values[\"ops\"] = OPS_LEVEL;\n    rootLogger.levels.labels[`${OPS_LEVEL}`] = \"ops\";\n    rootLogger.ops = rootLogger.error;\n}\nif (!rootLogger.progress || !rootLogger.levels.values.progress) {\n    rootLogger.levels.values[\"progress\"] = 25;\n    rootLogger.levels.labels[\"25\"] = \"progress\";\n    rootLogger.progress = rootLogger.info;\n}\nif (!rootLogger.isLevelEnabled) {\n    rootLogger.isLevelEnabled = isLevelEnabled;\n}\nfunction isLevelEnabled(logLevel) {\n    const { values } = this.levels;\n    const targetLogValue = values[logLevel];\n    const actualLogValue = values[this._level || this.level];\n    return targetLogValue !== undefined && targetLogValue >= actualLogValue;\n}\n\nrootLogger.consoleActivity = consoleActivity;\nrootLogger.consoleOnly = consoleOnly;\nrootLogger.consoleInfo = consoleInfo;\nrootLogger.consoleError = noConsoleError;\nrootLogger.consoleWarn = consoleWarn;\nrootLogger.consoleProgress = consoleProgress;\nrootLogger.progressInfo = progressInfo;\nrootLogger.bannerInfo = bannerInfo;\n\nconst { default: defaultLevel = \"warn\", ...defaults } = logLevelStringToObj(\n    localEnv(\"LOGGING\") || \"\",\n    rootLogger\n);\nif (hasStdOut) {\n    hasStdOut([\n        chalk.blue(`zonedLogger: default log levels: `),\n        JSON.stringify({ defaultLevel, ...defaults }),\n    ]);\n} else {\n    console.log(`zonedLogger: default log levels: `, {\n        defaultLevel,\n        ...defaults,\n    });\n}\n\ndefaults[\"log:overrides\"] = \"info\";\n\nif (rootLogger.levels.values[defaultLevel] > rootLogger.levels.values[\"warn\"]) {\n    throw new Error(\n        `disallowing requested default log level ${defaultLevel}.  Warnings are important, yo...`\n    );\n}\nrootLogger.baseLogLevels = { default: defaultLevel, ...defaults };\nrootLogger.level = defaultLevel;\n\n// these 2 functions have various entry points:\n// 1. from a startup script, which a) imports some libraries\n//    and b) calls forkZoneWithLogger(), then runs a function in\n//    that zone.\n// 2. from within the zone, in a library which calls zonedLogger()\n//    - normally from within (1b)\n// 3. while loading imports in (1a), a library calls zonedLogger()\n// 4. from other code such as React, where there may be no current\n//    zone in scope, but that code has another way of determining\n//    a parentZone and provides it through args\n//\n// In cases 2 & 4, we can make a child logger from the logger inherited\n// from the zone created in (1b).  In case 3, we need to construct\n// such a zone out of thin air like in case 1... without calling\n// back into zonedLogger()\n//\n// Solution: ensure that case 1 doesn't rely on zonedLogger(), which\n//   frees zonedLogger() to call forkZone...\n\nlet initZone;\nexport function contextLogger(loggerName, logProps = {}) {\n    if (logProps.addContext)\n        throw new Error(\n            `use zonedLogger to add context with logProps.addContext`\n        );\n\n    return zonedLogger(loggerName, { ...logProps, addContext: null });\n}\n\nexport function zonedLogger(loggerName, logProps = {}) {\n    let {\n        parentZone = Zone.current, // when provided, this is case 4.\n        addContext,\n        ...otherLogProps\n    } = logProps;\n    if (addContext && !Array.isArray(addContext)) {\n        addContext = [addContext];\n    }\n\n    if (!parentZone) debugger;\n\n    const filteredParentContext = (() => {\n        try {\n            return (parentZone.get(\"context\") || []).filter(\n                (x) => !x.chainedFrom\n            );\n        } catch (e) {\n            debugger;\n        }\n    })();\n\n    if (!otherLogProps.context && (addContext || addContext !== null)) {\n        if (!addContext && addContext !== null && parentZone.get(\"context\")) {\n            debugger;\n            zonedLogger(\"zone:context\", { addContext: null }).consoleWarn(\n                {\n                    detail: {\n                        loggerName,\n                        parentContext: parentZone.get(\"context\"),\n                    },\n                    summary: new Error(`here`).stack\n                        .split(\"\\n\")\n                        .slice(2)\n                        .join(\"\\n\"),\n                },\n                `zonedLogger: no addContext in logProps; retaining parentZone's context. \\n` +\n                    `Use addContext: \"identifying label\" to ensure your requested logger reflects your real context\\n` +\n                    `   or use contextLogger() or addContext: null, to suppress this message.`\n            );\n        }\n    }\n    if (!otherLogProps.context) {\n        otherLogProps.context = [\n            ...filteredParentContext,\n            ...(addContext || []),\n        ];\n    }\n\n    if (!parentZone.parent || !parentZone.get(\"logger\")) {\n        // case 3\n\n        parentZone = initZone =\n            initZone ||\n            forkZoneWithLogger(loggerName, otherLogProps, { name: \"‹init›\" });\n        // not really the current zone, but close enough during case 3.\n    } // else -> case 2\n    const parentLogger = parentZone.get(\"logger\");\n\n    // let {levels: logLevels={}, ...logSettings} = (logProps) || {};\n    // if (\"string\" == typeof logLevels) logLevels = stringToObj(logLevels);\n\n    // const contextLogLevels = Zone.current.get(\"logLevels\") || {};\n    // const baseLogLevels = Zone.current.get(\"baseLogLevels\") || parentLogger.baseLogLevels;\n\n    // const nextContextLevels = {\n    //   ...contextLogLevels,\n    //   ...withMinimumLevels(baseLogLevels, logLevels, parentLogger)\n    // };\n    // const logger = parentLogger.child({name:loggerName,\n    //   ...logSettings\n    // });\n    if (!loggerName) debugger;\n    otherLogProps.parentZone = parentZone;\n    const logger = mkLogger(parentLogger, loggerName, otherLogProps);\n\n    return logger;\n}\nfunction mkLogger(parentLogger, loggerName, logProps) {\n    let {\n        parentZone,\n        levels: logLevels = {},\n        options,\n        ...moreLogSettings\n    } = logProps || {};\n\n    if (!parentZone)\n        throw new Error(\n            \"mkLogger EXPECTS logProps (in arg 3) to have a parentZone\"\n        );\n\n    if (\"string\" == typeof logLevels)\n        logLevels = logLevelStringToObj(logLevels, parentLogger);\n\n    const contextLogLevels = parentZone.get(\"localLogLevels\") || {};\n    // console.warn(`##### context levels `, contextLogLevels)\n    const baseLogLevels =\n        parentZone.get(\"baseLogLevels\") || parentLogger.baseLogLevels;\n    // console.warn(`##### base levels`, baseLogLevels)\n\n    const nextContextLevels = Object.keys(logLevels).length\n        ? {\n              ...contextLogLevels,\n              ...withMinimumLevels(\n                  baseLogLevels,\n                  {\n                      ...contextLogLevels,\n                      ...logLevels,\n                  },\n                  parentLogger\n              ),\n          }\n        : { ...baseLogLevels, ...contextLogLevels };\n    // console.warn(`##### next context levels`, nextContextLevels)\n\n    let logger = createLogger(\n        { name: loggerName, ...essentialLogSettings, ...options },\n        logDest\n    );\n    logger.loggerName = loggerName;\n    logger.level =\n        nextContextLevels[loggerName] ||\n        nextContextLevels.default ||\n        parentLogger.level;\n    const { child: originalChild } = logger;\n    logger.child = function (loggerNameOrBindings, otherBindings) {\n        let logProps;\n        let loggerName;\n        if (\n            typeof loggerNameOrBindings === \"string\" ||\n            loggerNameOrBindings instanceof String\n        ) {\n            if (!this.zone)\n                throw new Error(\n                    `Developer error: can't use child(loggerName) on a logger without a zone`\n                );\n\n            loggerName = loggerNameOrBindings;\n            logProps = otherBindings || {};\n            logProps.parentZone = this.zone;\n            return contextLogger(loggerName, logProps);\n        } else if (loggerNameOrBindings.name) {\n            if (!this.zone)\n                throw new Error(\n                    `Developer error: can't use child({name}) on a logger without a zone`\n                );\n\n            const { name, ...otherLogProps } = loggerNameOrBindings;\n            loggerName = name;\n            logProps = otherLogProps;\n            logProps.parentZone = this.zone;\n            return contextLogger(loggerName, logProps);\n        }\n\n        if (otherBindings)\n            throw new Error(\n                `Developer error: child(bindings), child(loggerName, bindings): only one bindings args allowed`\n            );\n\n        const { parentZone, ...bindings } = loggerNameOrBindings;\n        if (parentZone) debugger;\n        const result = originalChild.call(this, bindings);\n\n        result.loggerName = this.loggerName;\n        result.chindings = bindings;\n\n        return result;\n    };\n    let enhancedLogProps = { ...parentLogger.chindings, ...moreLogSettings };\n\n    logger = logger.child(enhancedLogProps);\n    logger.consoleLogging = consoleLogging;\n\n    if (!logger.isLevelEnabled) logger.isLevelEnabled = isLevelEnabled;\n    if (!logger.hasOwnProperty(\"userError\")) {\n        logger.levels.values[\"userError\"] = USER_ERROR_LEVEL;\n        logger.levels.labels[`${USER_ERROR_LEVEL}`] = \"userError\";\n        logger.userError = child_process\n            ? logger.error\n            : logger.isLevelEnabled(\"userError\")\n            ? browserLogWriter.write.error\n            : browserLogWriter.write.noop;\n    }\n    if (!logger.hasOwnProperty(\"ops\")) {\n        logger.levels.values[\"ops\"] = OPS_LEVEL;\n        logger.levels.labels[`${OPS_LEVEL}`] = \"ops\";\n        logger.ops = child_process\n            ? logger.error\n            : logger.isLevelEnabled(\"ops\")\n            ? browserLogWriter.write.ops\n            : browserLogWriter.write.noop;\n    }\n    if (!logger.hasOwnProperty(\"progress\")) {\n        logger.levels.values[\"progress\"] = 25;\n        logger.levels.labels[\"25\"] = \"progress\";\n        // if (logger.level == \"progress\") debugger\n        logger.progress = child_process\n            ? logger.info\n            : logger.isLevelEnabled(\"progress\")\n            ? browserLogWriter.write.progress\n            : browserLogWriter.write.noop;\n    }\n\n    logger.consoleOnly = consoleOnly;\n    logger.consoleError = noConsoleError;\n    logger.consoleWarn = consoleWarn;\n    logger.consoleInfo = consoleInfo;\n    logger.progressInfo = progressInfo;\n    logger.bannerInfo = bannerInfo;\n    logger.consoleProgress = consoleProgress;\n    logger.consoleActivity = consoleActivity;\n\n    return logger;\n}\n\nexport function withExceptionsAsWarnings(proto, fieldName, descriptor) {\n    const { value: wrappedFunction } = descriptor;\n\n    descriptor.value = function exceptionToWarning(...args) {\n        return Zone.current.runWithWarnings(wrappedFunction, this, args);\n    };\n    return descriptor;\n}\n\nexport function addsContext(contextName, argsOrBadFieldName, badDescriptor) {\n    const usageMessage = `usage: @addsContext(contextName) someMethod(...)`;\n    let useFn = false;\n    let loggerName;\n    if (\"string\" === typeof argsOrBadFieldName) {\n        throw new Error(usageMessage);\n    } else if (argsOrBadFieldName) {\n        loggerName = argsOrBadFieldName.loggerName;\n    }\n    if (\"function\" === typeof contextName) {\n        useFn = true;\n    } else if (\"string\" !== typeof contextName) {\n        throw new Error(usageMessage);\n    }\n    return function txnDefinition(proto, fieldName, descriptor) {\n        const { value: wrappedFunction } = descriptor;\n        if (\"function\" !== typeof wrappedFunction) {\n            throw new Error(usageMessage);\n        }\n\n        descriptor.value = function wrappedWithContext(...args) {\n            const contextLabel = useFn\n                ? contextName.apply(this, args)\n                : contextName;\n            const location = new ZonedStackTrace();\n            const zone = loggerName\n                ? forkZoneWithContext(contextLabel, {\n                      loggerName,\n                      properties: { location },\n                  })\n                : forkZoneWithContext(contextLabel, {\n                      properties: { location, contextLabel },\n                  });\n            // zone.get(\"logger\").info(`running ${fieldName} in wrapped context ${contextLabel}`)\n\n            return zone.run(wrappedFunction, this, args);\n        };\n        // descriptor.value.name = (\"wrapped_wContext_\" + wrappedFunction.name);\n\n        return descriptor;\n    };\n}\n\n//! it can wrap non-class-method functions directly using functionWithContext()\nconst functionWithContextUsage = `usage: const wrappedFunc = functionWithContext(contextName, {loggerName}) ( innerFunc );`;\nexport function functionWithContext(contextName, { loggerName } = {}) {\n    return function (wrappedFunction) {\n        let useFn = false;\n        if (\"function\" === typeof contextName) {\n            useFn = true;\n        } else if (\"string\" !== typeof contextName) {\n            throw new Error(functionWithContextUsage);\n        }\n\n        return function wrappedWithContext(...args) {\n            const contextLabel = useFn\n                ? contextName.apply(this, args)\n                : contextName;\n            const location = new ZonedStackTrace();\n            const zone = loggerName\n                ? forkZoneWithContext(contextLabel, {\n                      loggerName,\n                      properties: { location },\n                  })\n                : forkZoneWithContext(contextLabel, {\n                      properties: { location, contextLabel },\n                  });\n            // zone.get(\"logger\").info(`running ${fieldName} in wrapped context ${contextLabel}`)\n\n            return zone.run(wrappedFunction, this, args);\n        };\n    };\n}\n\nexport function forkZoneWithContext(\n    addContext,\n    { loggerName, logProps = {}, ...zoneDetails } = {}\n) {\n    // const baseContext = Zone.current.get(\"context\") || [];\n    let { name, properties = {}, ...otherZoneSettings } = zoneDetails;\n    if (!name) name = addContext;\n    if (properties.context)\n        throw new Error(\n            `forkZoneWithContext: invalid use of arg2 {properties.context}'; just provide an incremental context string in arg 1`\n        );\n\n    let enhancedLogProps = logProps;\n    if (!loggerName) {\n        const currentLogger = Zone.current.get(\"logger\");\n        if (!currentLogger) {\n            if (\"test\" === process.env.NODE_ENV) {\n                loggerName = \"test\";\n            } else\n                throw new Error(\n                    `forkZoneWithContext: without existing parent context: {loggerName} required in arg2`\n                );\n        } else {\n            loggerName = currentLogger.loggerName;\n        }\n        const chindings = (currentLogger && currentLogger.chindings) || {};\n        enhancedLogProps = { ...chindings, ...logProps };\n    }\n\n    // const context = [...baseContext, addedContext];\n\n    const zone = forkZoneWithLogger(loggerName, enhancedLogProps, {\n        name,\n        properties: {\n            ...properties,\n            addContext,\n        },\n        ...otherZoneSettings,\n    });\n    const txnId = zone.get(\"txnId\");\n    const label = txnId ? ` ${txnId}` : \"\";\n    zone.get(\"logger\").progressInfo(\n        { summary: `${label}: ${addContext}`, consoleMethod: \"debug\" },\n        `+task`\n    );\n    return zone;\n    // return Zone.current.fork({\n    //   name,\n    //   properties: {\n    //     context,\n    //     ...properties\n    //   },\n    //   ...otherZoneSettings\n    // });\n}\n\n// decorator for methods to enable log levels\nexport function withLogLevels(levels, contextLabel = \"\") {\n    return function (proto, methodName, descriptor) {\n        const inner = descriptor.value;\n        descriptor.value = function (...args) {\n            const name = methodName + \"()\";\n            const className = this.constructor.name;\n            debugger;\n            const addContext = contextLabel || name;\n            const z = forkZoneWithLogger(\n                \"withLogLevels\",\n                {\n                    levels: {\n                        _message: `@withLogLevels() decorator on ${className}#${name}`,\n                        ...levels,\n                    },\n                    addContext,\n                },\n                { name, addContext }\n            );\n\n            return z.run(inner, this, args);\n        };\n        return descriptor;\n    };\n}\n\nexport function forkZoneWithLogger(loggerName, logProps, zoneDetails) {\n    // parentZone is provided when in case 4\n    const {\n        name,\n        parentZone = Zone.current,\n        properties: { addContext, ...zoneProperties } = {},\n        ...otherZoneSettings\n    } = zoneDetails || {};\n\n    let parentLogger = parentZone.get(\"logger\");\n\n    let { levels: logLevels, ...logSettings } = logProps || {};\n    if (addContext) {\n        const outerContext = parentZone.get(\"context\") || [];\n        zoneProperties.context = [...outerContext, addContext];\n    }\n\n    if (zoneProperties.context) {\n        logProps.context = [...zoneProperties.context];\n        if (logProps.context[0].chainedFrom) {\n            logProps.context = logProps.context.slice(1);\n        }\n    }\n\n    let logger;\n    if (!parentLogger) {\n        // case 1\n        if (!zoneDetails)\n            throw new Error(\n                `forkZoneWithLogger: missing required zone details.\\n` + usage2\n            );\n\n        parentLogger = rootLogger;\n        zoneProperties.baseLogLevels = rootLogger.baseLogLevels;\n        logProps.parentZone = parentZone;\n\n        // can't use zonedLogger yet... go straight to the source\n        // todo: verify logSettings in a valid use-case.\n        logger = mkLogger(rootLogger, loggerName, {\n            ...logProps,\n            ...logSettings,\n        });\n    } else {\n        // case 3/4\n        logProps.parentZone = parentZone;\n        logger = zonedLogger(loggerName, logProps);\n    }\n    // !!! get from/merge with parent zone log localLogLevels\n    if (\"string\" == typeof logLevels)\n        logLevels = logLevelStringToObj(logLevels, parentLogger);\n\n    zoneProperties.localLogLevels = logLevels;\n\n    if (!name)\n        throw new Error(\n            `forkZoneWithLogger: no {name} property in zoneDetails.\\n` + usage2\n        );\n\n    // logger.error({zoneProperties, zoneDetails }, \"where am I?\", new Error('stack'))\n\n    const newZone = parentZone.fork({\n        name,\n        properties: { logger, ...zoneProperties },\n        ...otherZoneSettings,\n    });\n    newZone.runWithWarnings = async function (\n        task,\n        applyThis,\n        applyArgs,\n        source\n    ) {\n        let zonedError;\n        const running = this.run(async () => {\n            const promise = task.apply(applyThis, applyArgs);\n            if (!promise) {\n                logger.consoleWarn(\n                    {\n                        summary:\n                            (task.name || \"‹anonymous func›\") +\n                            \" in context: \" +\n                            ((zoneProperties.context &&\n                                zoneProperties.context\n                                    .filter((x) => \"string\" === typeof x)\n                                    .reverse()\n                                    .join(\"\\n  ...in\")) ||\n                                \"\"),\n                    },\n                    `no promise returned from`\n                );\n                return promise;\n            }\n            return promise.catch((failed) => {\n                zonedError = failed.stack && failed.zoned && failed;\n                if (failed.stack && !zonedError) {\n                    zonedError = new ZonedStackTrace(\n                        failed.message ||\n                            message.reason ||\n                            JSON.stringify(failed)\n                    ).inZone(this);\n                    zonedError.setFilteredStack(failed.stack);\n                }\n                logger.consoleWarn(\n                    {\n                        summary: zonedError.message,\n                        detail: { stack: zonedError.stack.split(\"\\n\") },\n                    },\n                    `exception in zoned task`\n                );\n                logger.consoleWarn(\n                    `exception is converted to 'false'.  Remove  @withExceptionsAsWarnings to capture the exception upstream`\n                );\n                return false;\n            });\n        });\n        await running; // let it run, but let the caller deal with the exception, so it doesn't need\n        // to be raised as an uncaught exception here.\n        if (zonedError) return new Promise((res, rej) => rej(zonedError));\n        return running;\n    };\n    logger.zone = newZone;\n    return newZone;\n}\n\nfunction logLevelStringToObj(str, logger) {\n    const settings = str.split(\",\");\n    const obj = {};\n    for (const s of settings) {\n        const tokens = s.split(\":\");\n        if (tokens.length < 2 && !(tokens[0] || \"\")) continue;\n\n        let level = tokens[tokens.length - 1];\n        if (logger[level]) {\n            tokens.pop();\n        } else {\n            level = \"info\";\n        }\n        const facility = tokens.join(\":\");\n        if (logger.levels.values[level] > logger.levels.values[\"warn\"]) {\n            throw new Error(\n                `invalid log level '${level}' for ${facility} - use 'warn' at least.`\n            );\n        }\n        obj[facility] = level;\n    }\n    // console.log(str, \"toObj -> \", obj)\n    return obj;\n}\nfunction withMinimumLevels(minima, levels, logger) {\n    const obj = { ...minima };\n    const values = logger.levels.values;\n\n    const { _message = \"\", ...requestedLevels } = levels;\n\n    function metaLogger(logger) {\n        const l = logger.child({ name: \"zonedLogger\" });\n        if (!l.loggerName) l.loggerName = \"zonedLogger\";\n        return l\n    }\n\n    function warnLoggingOverride(k, v) {\n        const details = {\n            indent: \"        \",\n            summary: _message\n                ? `${k}=${v} by ${_message}`\n                : `${k}=${v} at ${new Error(\"here\").stack\n                      .split(\"\\n\")\n                      .slice(4)\n                      .join(\"\\n\")}`,\n        };\n        metaLogger(logger).consoleWarn(details, `▒▒▒▒ log override ▒▒▒▒`);\n    }\n\n    for (let [k, v] of Object.entries(requestedLevels)) {\n        if (\"default\" === k) {\n            // higher levels means trying to suppress more sever messages :(\n            if (values[levels.default] > values[minima.default]) {\n                metaLogger(logger).warn(\n                    `Using minimum level ${minima.default}, not levels.default=${levels.default}`\n                );\n                obj.default = minima.default;\n            } else {\n                warnLoggingOverride(k, v);\n                obj.default = v;\n                // defaultNumber = values[k];\n            }\n        } else {\n            if (v === true || v === null) v = \"info\";\n\n            if (!v)\n                throw new Error(\n                    `invalid falsey level provided for logger ${k}`\n                );\n            if (!values[v])\n                throw new Error(\n                    `invalid level '${v}' for logger ${k}; try one of (warn,userError,info,progress,debug,trace)`\n                );\n            if (values[v] > values[\"warn\"])\n                throw new Error(\n                    `Invalid level '${v}' for logger ${k}: use 'warn' at least.`\n                );\n            const minimumAllowableLevel = minima[k] || minima.default;\n            // larger values are worse severity, and trying to go larger with the target level\n            // means the caller is trying to suppress some log messages that need to be shown to\n            // comply with the environment-level setting:\n\n            if (values[v] > values[minimumAllowableLevel]) {\n                metaLogger(logger).warn(\n                    `${k}: using minimum level ${minimumAllowableLevel}, not suggested level=${v}`\n                );\n                obj[k] = minimumAllowableLevel;\n            } else {\n                warnLoggingOverride(k, v);\n                obj[k] = v;\n            }\n        }\n    }\n    return obj;\n}\n\nexport class ZonedStackTrace extends Error {\n    zoned = true;\n    //! captures a stack trace without any special message\n    static snapshot() {\n        const zst = new this(\"stack snapshot\");\n        zst.isSnapshot = true;\n        return zst;\n    }\n\n    //! converts an error to zoned, if needed\n    static fromError(e) {\n        if (e.zoned) return e;\n        const zst = new this(e.message || e);\n        zst.stack = e.stack;\n        return zst;\n    }\n    constructor(...args) {\n        super(...args);\n        let splitStack = this.stack;\n        this._zone = Zone.current;\n        Object.defineProperty(this, \"_stack\", {\n            enumerable: false,\n            writable: true,\n        });\n        Object.defineProperty(this, \"_zone\", {\n            enumerable: false,\n            writable: true,\n        });\n        Object.defineProperty(this, \"stack\", {\n            set(v) {\n                this._stack = v;\n            },\n            get() {\n                return this._stack || this.setFilteredStack(splitStack);\n            },\n        });\n    }\n\n    inZone(zone) {\n        this._zone = zone;\n        return this;\n    }\n\n    setStack(i) {\n        this.setFilteredStack(i);\n    }\n\n    setFilteredStack(inputStack, defaultTrim) {\n        //!!! put a mark-and-count logger on this to validate\n        //  that no hot code paths use this... this can't not be\n        //  a eyebrow-raiser w/r/t potential peformance problems.\n        //  but, we measure.\n\n        if (inputStack.match(/Maximum call stac/)) debugger;\n\n        let s = inputStack.split(\"\\n\");\n        //!!! HAVING EXTRA error message in stack?  -> consider using snapshot or switching to new ZonedStackTrace(message)\n        if (this.isSnapshot) s = s.slice(2);\n\n        const enhancedStack = s.filter((l) => {\n            if (l.trim().match(/^at Generator\\./)) return false;\n            if (l.trim().match(/^at asyncGeneratorStep/)) return false;\n            if (l.trim().match(/^at _next/)) return false;\n            if (l.trim().match(/^at new ZoneAwarePromise/)) return false;\n            if (l.trim().match(/^at processTicksAndRejections/)) return false;\n            if (l.trim().match(/drainMicroTaskQueue/)) return false;\n            if (l.trim().match(/zoned-cls-node/)) return false;\n            if (l.trim().match(/^at Zone/)) return false;\n\n            return true;\n        });\n        const z = this._zone || Zone.current;\n        const contextLocation = z.get(\"location\");\n        const contextReversed = [...(z.get(\"context\") || [])].reverse();\n        // if (contextLocation && contextLocation !== this) {\n        //   // todo: check if it's possible for the current zone to be different from the context zone, such that\n        //   // there can be one or more contextLocations that are included in the local  context\n        //   //   and not included in the contextLocation's stack info\n        //\n        //     enhancedStack.push(`[ from context ${contextReversed[0]} at location:`, contextLocation.stack, \"]\")\n        // } else {\n        for (const c of contextReversed) {\n            if (c.chainedFrom) continue;\n            if (\"string\" === typeof c)\n                enhancedStack.push(`   [at async context ${c}]`);\n            if (c.label)\n                enhancedStack.push(\n                    `   [at async context ${c.label} ${\n                        c.id || \"‹no context id›\"\n                    }]`\n                );\n        }\n        // }\n\n        return (this._stack = enhancedStack.join(\"\\n\"));\n    }\n}\n",{"ruleId":"602","severity":2,"message":"603","line":6,"column":14,"nodeType":"604","messageId":"605","endLine":6,"endColumn":21},{"ruleId":"606","severity":2,"message":"607","line":7,"column":1,"nodeType":"608","endLine":7,"endColumn":45,"fix":"609"},{"ruleId":"602","severity":2,"message":"603","line":9,"column":14,"nodeType":"604","messageId":"605","endLine":9,"endColumn":21},{"ruleId":"606","severity":2,"message":"610","line":8,"column":1,"nodeType":"608","endLine":8,"endColumn":52,"fix":"611"},{"ruleId":"612","severity":2,"message":"613","line":8,"column":26,"nodeType":"614","endLine":8,"endColumn":51},{"ruleId":"615","severity":1,"message":"616","line":18,"column":13,"nodeType":"604","messageId":"617","endLine":18,"endColumn":17,"fix":"618"},{"ruleId":"615","severity":1,"message":"616","line":67,"column":13,"nodeType":"604","messageId":"617","endLine":67,"endColumn":17,"fix":"619"},{"ruleId":"615","severity":1,"message":"616","line":93,"column":13,"nodeType":"604","messageId":"617","endLine":93,"endColumn":17,"fix":"620"},{"ruleId":"615","severity":1,"message":"621","line":131,"column":13,"nodeType":"604","messageId":"617","endLine":131,"endColumn":18,"fix":"622"},{"ruleId":"623","severity":2,"message":"624","line":133,"column":30,"nodeType":"625","messageId":"626","endLine":133,"endColumn":44},{"ruleId":"615","severity":1,"message":"627","line":138,"column":21,"nodeType":"604","messageId":"617","endLine":138,"endColumn":29,"fix":"628"},{"ruleId":"615","severity":1,"message":"629","line":146,"column":21,"nodeType":"604","messageId":"617","endLine":146,"endColumn":30,"fix":"630"},{"ruleId":"615","severity":1,"message":"631","line":162,"column":13,"nodeType":"604","messageId":"617","endLine":162,"endColumn":24,"fix":"632"},{"ruleId":"615","severity":1,"message":"633","line":163,"column":13,"nodeType":"604","messageId":"617","endLine":163,"endColumn":28,"fix":"634"},{"ruleId":"615","severity":1,"message":"635","line":198,"column":29,"nodeType":"604","messageId":"617","endLine":198,"endColumn":38,"fix":"636"},{"ruleId":"623","severity":2,"message":"637","line":211,"column":34,"nodeType":"625","messageId":"626","endLine":211,"endColumn":47},{"ruleId":"615","severity":1,"message":"629","line":214,"column":17,"nodeType":"604","messageId":"617","endLine":214,"endColumn":26,"fix":"638"},{"ruleId":"615","severity":1,"message":"639","line":215,"column":17,"nodeType":"604","messageId":"617","endLine":215,"endColumn":33,"fix":"640"},{"ruleId":"615","severity":1,"message":"629","line":257,"column":17,"nodeType":"604","messageId":"617","endLine":257,"endColumn":26,"fix":"641"},{"ruleId":"615","severity":1,"message":"635","line":286,"column":29,"nodeType":"604","messageId":"617","endLine":286,"endColumn":38,"fix":"642"},{"ruleId":"643","severity":2,"message":"644","line":313,"column":31,"nodeType":"604","messageId":"645","endLine":313,"endColumn":32},{"ruleId":"646","severity":1,"message":"647","line":324,"column":40,"nodeType":"648","messageId":"649","endLine":324,"endColumn":42},{"ruleId":"646","severity":1,"message":"647","line":330,"column":38,"nodeType":"648","messageId":"649","endLine":330,"endColumn":40},{"ruleId":"650","severity":2,"message":"651","line":187,"column":25,"nodeType":"652","messageId":"649","endLine":187,"endColumn":34,"suppressions":"653"},{"ruleId":"650","severity":2,"message":"651","line":193,"column":59,"nodeType":"652","messageId":"649","endLine":193,"endColumn":68,"suppressions":"654"},{"ruleId":"650","severity":2,"message":"651","line":195,"column":41,"nodeType":"652","messageId":"649","endLine":195,"endColumn":50,"suppressions":"655"},{"ruleId":"650","severity":2,"message":"651","line":221,"column":37,"nodeType":"652","messageId":"649","endLine":221,"endColumn":46,"suppressions":"656"},{"ruleId":"650","severity":2,"message":"651","line":298,"column":52,"nodeType":"652","messageId":"649","endLine":298,"endColumn":61,"suppressions":"657"},{"ruleId":"650","severity":2,"message":"651","line":300,"column":56,"nodeType":"652","messageId":"649","endLine":300,"endColumn":65,"suppressions":"658"},{"ruleId":"650","severity":2,"message":"651","line":321,"column":25,"nodeType":"652","messageId":"649","endLine":321,"endColumn":34,"suppressions":"659"},{"ruleId":"660","severity":2,"message":"661","line":6,"column":19,"nodeType":"662","messageId":"663","endLine":6,"endColumn":48},{"ruleId":"660","severity":2,"message":"664","line":6,"column":20,"nodeType":"665","messageId":"666","endLine":6,"endColumn":44},{"ruleId":"606","severity":2,"message":"667","line":7,"column":1,"nodeType":"608","endLine":7,"endColumn":52,"fix":"668"},{"ruleId":"612","severity":2,"message":"613","line":7,"column":26,"nodeType":"614","endLine":7,"endColumn":51},{"ruleId":"669","severity":2,"message":"670","line":9,"column":17,"nodeType":"604","messageId":"671","endLine":9,"endColumn":23},{"ruleId":"615","severity":1,"message":"672","line":68,"column":17,"nodeType":"604","messageId":"617","endLine":68,"endColumn":27,"fix":"673"},{"ruleId":"674","severity":2,"message":"675","line":96,"column":5,"nodeType":"676","messageId":"649","endLine":102,"endColumn":6},{"ruleId":"669","severity":2,"message":"677","line":99,"column":13,"nodeType":"604","messageId":"671","endLine":99,"endColumn":34},{"ruleId":"674","severity":2,"message":"678","line":103,"column":5,"nodeType":"676","messageId":"649","endLine":124,"endColumn":6},{"ruleId":"669","severity":2,"message":"679","line":104,"column":25,"nodeType":"604","messageId":"671","endLine":104,"endColumn":33},{"ruleId":"615","severity":1,"message":"680","line":107,"column":19,"nodeType":"604","messageId":"617","endLine":107,"endColumn":27,"fix":"681"},{"ruleId":"615","severity":1,"message":"682","line":107,"column":29,"nodeType":"604","messageId":"617","endLine":107,"endColumn":36,"fix":"683"},{"ruleId":"615","severity":1,"message":"684","line":107,"column":38,"nodeType":"604","messageId":"617","endLine":107,"endColumn":45,"fix":"685"},{"ruleId":"674","severity":2,"message":"686","line":125,"column":5,"nodeType":"676","messageId":"649","endLine":304,"endColumn":6},{"ruleId":"669","severity":2,"message":"687","line":156,"column":66,"nodeType":"604","messageId":"671","endLine":156,"endColumn":84},{"ruleId":"650","severity":2,"message":"651","line":177,"column":36,"nodeType":"652","messageId":"649","endLine":177,"endColumn":45},{"ruleId":"650","severity":2,"message":"651","line":183,"column":51,"nodeType":"652","messageId":"649","endLine":183,"endColumn":60},{"ruleId":"646","severity":1,"message":"647","line":186,"column":42,"nodeType":"648","messageId":"649","endLine":186,"endColumn":44},{"ruleId":"646","severity":1,"message":"647","line":187,"column":45,"nodeType":"648","messageId":"649","endLine":187,"endColumn":47},{"ruleId":"646","severity":1,"message":"647","line":188,"column":45,"nodeType":"648","messageId":"649","endLine":188,"endColumn":47},{"ruleId":"650","severity":2,"message":"651","line":194,"column":40,"nodeType":"652","messageId":"649","endLine":194,"endColumn":49},{"ruleId":"650","severity":2,"message":"651","line":244,"column":25,"nodeType":"652","messageId":"649","endLine":244,"endColumn":34},{"ruleId":"646","severity":1,"message":"647","line":259,"column":60,"nodeType":"648","messageId":"649","endLine":259,"endColumn":62},{"ruleId":"674","severity":2,"message":"688","line":318,"column":5,"nodeType":"676","messageId":"649","endLine":322,"endColumn":6},{"ruleId":"615","severity":1,"message":"689","line":320,"column":13,"nodeType":"604","messageId":"617","endLine":320,"endColumn":27,"fix":"690"},{"ruleId":"669","severity":2,"message":"679","line":337,"column":25,"nodeType":"604","messageId":"671","endLine":337,"endColumn":33},{"ruleId":"669","severity":2,"message":"679","line":343,"column":25,"nodeType":"604","messageId":"671","endLine":343,"endColumn":33},{"ruleId":"646","severity":1,"message":"647","line":407,"column":43,"nodeType":"648","messageId":"649","endLine":407,"endColumn":45},{"ruleId":"612","severity":2,"message":"613","line":4,"column":26,"nodeType":"614","endLine":4,"endColumn":51},{"ruleId":"691","severity":2,"message":"692","line":5,"column":29,"nodeType":"693","messageId":"694","endLine":5,"endColumn":34,"fix":"695"},{"ruleId":"615","severity":1,"message":"696","line":110,"column":15,"nodeType":"604","messageId":"617","endLine":110,"endColumn":22,"fix":"697"},{"ruleId":"615","severity":1,"message":"698","line":110,"column":29,"nodeType":"604","messageId":"617","endLine":110,"endColumn":33,"fix":"699"},{"ruleId":"615","severity":1,"message":"700","line":111,"column":13,"nodeType":"604","messageId":"617","endLine":111,"endColumn":20,"fix":"701"},{"ruleId":"612","severity":2,"message":"613","line":3,"column":26,"nodeType":"614","endLine":3,"endColumn":51},{"ruleId":"650","severity":2,"message":"651","line":23,"column":13,"nodeType":"652","messageId":"649","endLine":23,"endColumn":21},{"ruleId":"615","severity":1,"message":"702","line":6,"column":5,"nodeType":"604","messageId":"617","endLine":6,"endColumn":10,"fix":"703"},{"ruleId":"615","severity":1,"message":"704","line":15,"column":5,"nodeType":"604","messageId":"617","endLine":15,"endColumn":9,"fix":"705"},{"ruleId":"615","severity":1,"message":"706","line":21,"column":5,"nodeType":"604","messageId":"617","endLine":21,"endColumn":10,"fix":"707"},{"ruleId":"615","severity":1,"message":"708","line":27,"column":5,"nodeType":"604","messageId":"617","endLine":27,"endColumn":9,"fix":"709"},{"ruleId":"615","severity":1,"message":"702","line":47,"column":14,"nodeType":"604","messageId":"617","endLine":47,"endColumn":19,"fix":"710"},{"ruleId":"615","severity":1,"message":"704","line":47,"column":21,"nodeType":"604","messageId":"617","endLine":47,"endColumn":25,"fix":"711"},{"ruleId":"615","severity":1,"message":"712","line":47,"column":27,"nodeType":"604","messageId":"617","endLine":47,"endColumn":38,"fix":"713"},{"ruleId":"615","severity":1,"message":"708","line":47,"column":40,"nodeType":"604","messageId":"617","endLine":47,"endColumn":44,"fix":"714"},{"ruleId":"615","severity":1,"message":"715","line":47,"column":46,"nodeType":"604","messageId":"617","endLine":47,"endColumn":52,"fix":"716"},{"ruleId":"615","severity":1,"message":"706","line":47,"column":54,"nodeType":"604","messageId":"617","endLine":47,"endColumn":59,"fix":"717"},{"ruleId":"650","severity":2,"message":"651","line":60,"column":20,"nodeType":"652","messageId":"649","endLine":60,"endColumn":29},{"ruleId":"615","severity":1,"message":"718","line":61,"column":13,"nodeType":"604","messageId":"617","endLine":61,"endColumn":17,"fix":"719"},{"ruleId":"615","severity":1,"message":"720","line":20,"column":15,"nodeType":"604","messageId":"617","endLine":20,"endColumn":20,"fix":"721"},{"ruleId":"615","severity":1,"message":"722","line":19,"column":15,"nodeType":"604","messageId":"617","endLine":19,"endColumn":22,"fix":"723"},{"ruleId":"615","severity":1,"message":"724","line":19,"column":24,"nodeType":"604","messageId":"617","endLine":19,"endColumn":31,"fix":"725"},{"ruleId":"615","severity":1,"message":"720","line":19,"column":33,"nodeType":"604","messageId":"617","endLine":19,"endColumn":38,"fix":"726"},{"ruleId":"650","severity":2,"message":"651","line":69,"column":31,"nodeType":"652","messageId":"649","endLine":69,"endColumn":40},{"ruleId":"660","severity":2,"message":"661","line":10,"column":5,"nodeType":"727","messageId":"663","endLine":10,"endColumn":13},{"ruleId":"646","severity":1,"message":"647","line":23,"column":29,"nodeType":"648","messageId":"649","endLine":23,"endColumn":31},{"ruleId":"646","severity":1,"message":"647","line":25,"column":36,"nodeType":"648","messageId":"649","endLine":25,"endColumn":38},{"ruleId":"669","severity":2,"message":"728","line":134,"column":38,"nodeType":"604","messageId":"671","endLine":134,"endColumn":47},{"ruleId":"646","severity":1,"message":"647","line":206,"column":16,"nodeType":"648","messageId":"649","endLine":206,"endColumn":18},{"ruleId":"646","severity":1,"message":"647","line":318,"column":16,"nodeType":"648","messageId":"649","endLine":318,"endColumn":18},{"ruleId":"646","severity":1,"message":"647","line":318,"column":34,"nodeType":"648","messageId":"649","endLine":318,"endColumn":36},{"ruleId":"646","severity":1,"message":"647","line":318,"column":51,"nodeType":"648","messageId":"649","endLine":318,"endColumn":53},{"ruleId":"646","severity":1,"message":"647","line":318,"column":67,"nodeType":"648","messageId":"649","endLine":318,"endColumn":69},{"ruleId":"623","severity":2,"message":"624","line":337,"column":22,"nodeType":"625","messageId":"626","endLine":337,"endColumn":36},{"ruleId":"646","severity":1,"message":"647","line":361,"column":16,"nodeType":"648","messageId":"649","endLine":361,"endColumn":18},{"ruleId":"646","severity":1,"message":"729","line":411,"column":30,"nodeType":"648","messageId":"649","endLine":411,"endColumn":32},{"ruleId":"646","severity":1,"message":"730","line":434,"column":17,"nodeType":"648","messageId":"649","endLine":434,"endColumn":20},{"ruleId":"669","severity":2,"message":"679","line":434,"column":41,"nodeType":"604","messageId":"671","endLine":434,"endColumn":49},{"ruleId":"643","severity":2,"message":"644","line":446,"column":9,"nodeType":"604","messageId":"645","endLine":446,"endColumn":13},{"ruleId":"669","severity":2,"message":"679","line":448,"column":38,"nodeType":"604","messageId":"671","endLine":448,"endColumn":46},{"ruleId":"646","severity":1,"message":"647","line":568,"column":20,"nodeType":"648","messageId":"649","endLine":568,"endColumn":22},{"ruleId":"646","severity":1,"message":"729","line":582,"column":47,"nodeType":"648","messageId":"649","endLine":582,"endColumn":49},{"ruleId":"646","severity":1,"message":"729","line":589,"column":24,"nodeType":"648","messageId":"649","endLine":589,"endColumn":26},{"ruleId":"646","severity":1,"message":"647","line":601,"column":25,"nodeType":"648","messageId":"649","endLine":601,"endColumn":27},{"ruleId":"646","severity":1,"message":"647","line":610,"column":53,"nodeType":"648","messageId":"649","endLine":610,"endColumn":55},{"ruleId":"646","severity":1,"message":"647","line":613,"column":34,"nodeType":"648","messageId":"649","endLine":613,"endColumn":36},{"ruleId":"646","severity":1,"message":"647","line":614,"column":36,"nodeType":"648","messageId":"649","endLine":614,"endColumn":38},{"ruleId":"646","severity":1,"message":"729","line":686,"column":40,"nodeType":"648","messageId":"649","endLine":686,"endColumn":42},{"ruleId":"646","severity":1,"message":"647","line":731,"column":41,"nodeType":"648","messageId":"649","endLine":731,"endColumn":43},{"ruleId":"646","severity":1,"message":"647","line":733,"column":20,"nodeType":"648","messageId":"649","endLine":733,"endColumn":22},{"ruleId":"646","severity":1,"message":"647","line":740,"column":67,"nodeType":"648","messageId":"649","endLine":740,"endColumn":69},{"ruleId":"646","severity":1,"message":"647","line":919,"column":20,"nodeType":"648","messageId":"649","endLine":919,"endColumn":22},{"ruleId":"643","severity":2,"message":"644","line":944,"column":9,"nodeType":"604","messageId":"645","endLine":944,"endColumn":13},{"ruleId":"643","severity":2,"message":"644","line":970,"column":9,"nodeType":"604","messageId":"645","endLine":970,"endColumn":13},{"ruleId":"643","severity":2,"message":"644","line":994,"column":9,"nodeType":"604","messageId":"645","endLine":994,"endColumn":13},{"ruleId":"731","severity":2,"message":"732","line":995,"column":51,"nodeType":"727","messageId":"649","endLine":995,"endColumn":53},{"ruleId":"643","severity":2,"message":"644","line":1006,"column":9,"nodeType":"604","messageId":"645","endLine":1006,"endColumn":13},{"ruleId":"643","severity":2,"message":"644","line":1021,"column":9,"nodeType":"604","messageId":"645","endLine":1021,"endColumn":13},{"ruleId":"643","severity":2,"message":"644","line":1035,"column":9,"nodeType":"604","messageId":"645","endLine":1035,"endColumn":13},{"ruleId":"646","severity":1,"message":"647","line":1048,"column":25,"nodeType":"648","messageId":"649","endLine":1048,"endColumn":27},{"ruleId":"646","severity":1,"message":"647","line":1049,"column":25,"nodeType":"648","messageId":"649","endLine":1049,"endColumn":27},{"ruleId":"646","severity":1,"message":"647","line":1050,"column":25,"nodeType":"648","messageId":"649","endLine":1050,"endColumn":27},{"ruleId":"643","severity":2,"message":"644","line":1059,"column":9,"nodeType":"604","messageId":"645","endLine":1059,"endColumn":13},{"ruleId":"623","severity":2,"message":"624","line":1068,"column":20,"nodeType":"625","messageId":"626","endLine":1068,"endColumn":34},{"ruleId":"669","severity":2,"message":"679","line":1082,"column":39,"nodeType":"604","messageId":"671","endLine":1082,"endColumn":47},{"ruleId":"615","severity":1,"message":"733","line":2,"column":12,"nodeType":"604","messageId":"617","endLine":2,"endColumn":32,"fix":"734"},{"ruleId":"669","severity":2,"message":"735","line":2,"column":36,"nodeType":"604","messageId":"671","endLine":2,"endColumn":40},{"ruleId":"669","severity":2,"message":"670","line":2,"column":44,"nodeType":"604","messageId":"671","endLine":2,"endColumn":50},{"ruleId":"736","severity":2,"message":"737","line":1,"column":36,"nodeType":"604","messageId":"738","endLine":1,"endColumn":47},{"ruleId":"669","severity":2,"message":"735","line":4,"column":10,"nodeType":"604","messageId":"671","endLine":4,"endColumn":14},{"ruleId":"669","severity":2,"message":"735","line":5,"column":11,"nodeType":"604","messageId":"671","endLine":5,"endColumn":15},{"ruleId":"669","severity":2,"message":"735","line":5,"column":28,"nodeType":"604","messageId":"671","endLine":5,"endColumn":32},{"ruleId":"669","severity":2,"message":"739","line":8,"column":12,"nodeType":"604","messageId":"671","endLine":8,"endColumn":24},{"ruleId":"615","severity":1,"message":"733","line":4,"column":12,"nodeType":"604","messageId":"617","endLine":4,"endColumn":32,"fix":"740"},{"ruleId":"741","severity":2,"message":"742","line":1,"column":1,"nodeType":"743","endLine":1,"endColumn":48},{"ruleId":"612","severity":2,"message":"744","line":1,"column":31,"nodeType":"614","endLine":1,"endColumn":56},{"ruleId":"745","severity":2,"message":"746","line":19,"column":17,"nodeType":"747","messageId":"748","endLine":19,"endColumn":56,"fix":"749"},{"ruleId":"750","severity":2,"message":"751","line":32,"column":20,"nodeType":"614","messageId":"649","endLine":32,"endColumn":23,"fix":"752"},{"ruleId":"602","severity":2,"message":"753","line":35,"column":57,"nodeType":"604","messageId":"605","endLine":35,"endColumn":66},{"ruleId":"602","severity":2,"message":"753","line":37,"column":63,"nodeType":"604","messageId":"605","endLine":37,"endColumn":72},{"ruleId":"650","severity":2,"message":"651","line":38,"column":9,"nodeType":"652","messageId":"649","endLine":38,"endColumn":18},{"ruleId":"741","severity":2,"message":"754","line":1,"column":1,"nodeType":"743","endLine":1,"endColumn":26},{"ruleId":"736","severity":2,"message":"755","line":1,"column":1,"nodeType":"743","messageId":"738","endLine":1,"endColumn":26},{"ruleId":"736","severity":2,"message":"756","line":1,"column":1,"nodeType":"743","messageId":"738","endLine":1,"endColumn":26},{"ruleId":"741","severity":2,"message":"757","line":9,"column":1,"nodeType":"608","endLine":9,"endColumn":29},{"ruleId":"606","severity":2,"message":"758","line":9,"column":1,"nodeType":"608","endLine":9,"endColumn":29,"fix":"759"},{"ruleId":"602","severity":2,"message":"603","line":16,"column":14,"nodeType":"604","messageId":"605","endLine":16,"endColumn":21},{"ruleId":"602","severity":2,"message":"603","line":6,"column":14,"nodeType":"604","messageId":"605","endLine":6,"endColumn":21},{"ruleId":"741","severity":2,"message":"757","line":8,"column":1,"nodeType":"608","endLine":8,"endColumn":29},{"ruleId":"606","severity":2,"message":"758","line":8,"column":1,"nodeType":"608","endLine":8,"endColumn":29},{"ruleId":"612","severity":2,"message":"760","line":3,"column":35,"nodeType":"614","endLine":3,"endColumn":58},{"ruleId":"612","severity":2,"message":"761","line":4,"column":36,"nodeType":"614","endLine":4,"endColumn":60},{"ruleId":"669","severity":2,"message":"728","line":8,"column":13,"nodeType":"604","messageId":"671","endLine":8,"endColumn":22},{"ruleId":"615","severity":1,"message":"762","line":11,"column":13,"nodeType":"604","messageId":"617","endLine":11,"endColumn":24,"fix":"763"},{"ruleId":"615","severity":1,"message":"764","line":12,"column":13,"nodeType":"604","messageId":"617","endLine":12,"endColumn":22,"fix":"765"},{"ruleId":"615","severity":1,"message":"764","line":28,"column":13,"nodeType":"604","messageId":"617","endLine":28,"endColumn":22,"fix":"766"},{"ruleId":"615","severity":1,"message":"767","line":35,"column":13,"nodeType":"604","messageId":"617","endLine":35,"endColumn":19,"fix":"768"},{"ruleId":"615","severity":1,"message":"769","line":44,"column":13,"nodeType":"604","messageId":"617","endLine":44,"endColumn":16,"fix":"770"},{"ruleId":"615","severity":1,"message":"762","line":88,"column":13,"nodeType":"604","messageId":"617","endLine":88,"endColumn":24,"fix":"771"},{"ruleId":"615","severity":1,"message":"767","line":89,"column":13,"nodeType":"604","messageId":"617","endLine":89,"endColumn":19,"fix":"772"},{"ruleId":"615","severity":1,"message":"773","line":122,"column":13,"nodeType":"604","messageId":"617","endLine":122,"endColumn":16,"fix":"774"},{"ruleId":"615","severity":1,"message":"775","line":143,"column":13,"nodeType":"604","messageId":"617","endLine":143,"endColumn":19,"fix":"776"},{"ruleId":"615","severity":1,"message":"777","line":148,"column":15,"nodeType":"604","messageId":"617","endLine":148,"endColumn":16,"fix":"778"},{"ruleId":"615","severity":1,"message":"779","line":148,"column":18,"nodeType":"604","messageId":"617","endLine":148,"endColumn":21,"fix":"780"},{"ruleId":"615","severity":1,"message":"781","line":148,"column":23,"nodeType":"604","messageId":"617","endLine":148,"endColumn":24,"fix":"782"},{"ruleId":"615","severity":1,"message":"783","line":153,"column":13,"nodeType":"604","messageId":"617","endLine":153,"endColumn":17,"fix":"784"},{"ruleId":"615","severity":1,"message":"773","line":158,"column":13,"nodeType":"604","messageId":"617","endLine":158,"endColumn":16,"fix":"785"},{"ruleId":"691","severity":2,"message":"786","line":3,"column":51,"nodeType":"693","messageId":"694","endLine":3,"endColumn":66,"fix":"787"},{"ruleId":"788","severity":2,"message":"789","line":176,"column":17,"nodeType":"790","messageId":"791","endLine":176,"endColumn":35},{"ruleId":"650","severity":2,"message":"651","line":192,"column":21,"nodeType":"652","messageId":"649","endLine":192,"endColumn":29},{"ruleId":"646","severity":1,"message":"647","line":251,"column":39,"nodeType":"648","messageId":"649","endLine":251,"endColumn":41},{"ruleId":"643","severity":2,"message":"644","line":263,"column":35,"nodeType":"604","messageId":"645","endLine":263,"endColumn":42},{"ruleId":"792","severity":2,"message":"793","line":268,"column":33,"nodeType":"794","messageId":"795","endLine":272,"endColumn":34},{"ruleId":"646","severity":1,"message":"647","line":278,"column":48,"nodeType":"648","messageId":"649","endLine":278,"endColumn":50},{"ruleId":"792","severity":2,"message":"793","line":313,"column":37,"nodeType":"794","messageId":"795","endLine":322,"endColumn":38},{"ruleId":"650","severity":2,"message":"651","line":332,"column":29,"nodeType":"652","messageId":"649","endLine":332,"endColumn":38},{"ruleId":"650","severity":2,"message":"651","line":344,"column":41,"nodeType":"652","messageId":"649","endLine":344,"endColumn":50},{"ruleId":"615","severity":1,"message":"796","line":364,"column":23,"nodeType":"604","messageId":"617","endLine":364,"endColumn":35,"fix":"797"},{"ruleId":"615","severity":1,"message":"796","line":426,"column":15,"nodeType":"604","messageId":"617","endLine":426,"endColumn":27,"fix":"798"},{"ruleId":"615","severity":1,"message":"799","line":427,"column":13,"nodeType":"604","messageId":"617","endLine":427,"endColumn":22,"fix":"800"},{"ruleId":"615","severity":1,"message":"801","line":430,"column":13,"nodeType":"604","messageId":"617","endLine":430,"endColumn":20,"fix":"802"},{"ruleId":"615","severity":1,"message":"803","line":431,"column":22,"nodeType":"604","messageId":"617","endLine":431,"endColumn":36,"fix":"804"},{"ruleId":"615","severity":1,"message":"805","line":432,"column":16,"nodeType":"604","messageId":"617","endLine":432,"endColumn":31,"fix":"806"},{"ruleId":"646","severity":1,"message":"647","line":439,"column":38,"nodeType":"648","messageId":"649","endLine":439,"endColumn":40},{"ruleId":"615","severity":1,"message":"796","line":446,"column":15,"nodeType":"604","messageId":"617","endLine":446,"endColumn":27,"fix":"807"},{"ruleId":"615","severity":1,"message":"799","line":447,"column":13,"nodeType":"604","messageId":"617","endLine":447,"endColumn":22,"fix":"808"},{"ruleId":"615","severity":1,"message":"801","line":449,"column":13,"nodeType":"604","messageId":"617","endLine":449,"endColumn":20,"fix":"809"},{"ruleId":"615","severity":1,"message":"803","line":450,"column":22,"nodeType":"604","messageId":"617","endLine":450,"endColumn":36,"fix":"810"},{"ruleId":"615","severity":1,"message":"805","line":451,"column":16,"nodeType":"604","messageId":"617","endLine":451,"endColumn":31,"fix":"811"},{"ruleId":"646","severity":1,"message":"647","line":454,"column":23,"nodeType":"648","messageId":"649","endLine":454,"endColumn":25},{"ruleId":"646","severity":1,"message":"647","line":455,"column":45,"nodeType":"648","messageId":"649","endLine":455,"endColumn":47},{"ruleId":"615","severity":1,"message":"812","line":465,"column":13,"nodeType":"604","messageId":"617","endLine":465,"endColumn":22,"fix":"813"},{"ruleId":"615","severity":1,"message":"796","line":471,"column":15,"nodeType":"604","messageId":"617","endLine":471,"endColumn":27,"fix":"814"},{"ruleId":"615","severity":1,"message":"815","line":483,"column":13,"nodeType":"604","messageId":"617","endLine":483,"endColumn":18,"fix":"816"},{"ruleId":"650","severity":2,"message":"651","line":490,"column":21,"nodeType":"652","messageId":"649","endLine":490,"endColumn":30},{"ruleId":"615","severity":1,"message":"817","line":512,"column":13,"nodeType":"604","messageId":"617","endLine":512,"endColumn":27,"fix":"818"},{"ruleId":"615","severity":1,"message":"819","line":519,"column":13,"nodeType":"604","messageId":"617","endLine":519,"endColumn":19,"fix":"820"},{"ruleId":"615","severity":1,"message":"819","line":540,"column":13,"nodeType":"604","messageId":"617","endLine":540,"endColumn":19,"fix":"821"},{"ruleId":"669","severity":2,"message":"822","line":540,"column":22,"nodeType":"604","messageId":"671","endLine":540,"endColumn":26},{"ruleId":"615","severity":1,"message":"796","line":544,"column":15,"nodeType":"604","messageId":"617","endLine":544,"endColumn":27,"fix":"823"},{"ruleId":"615","severity":1,"message":"824","line":545,"column":13,"nodeType":"604","messageId":"617","endLine":545,"endColumn":25,"fix":"825"},{"ruleId":"615","severity":1,"message":"826","line":546,"column":13,"nodeType":"604","messageId":"617","endLine":546,"endColumn":23,"fix":"827"},{"ruleId":"615","severity":1,"message":"799","line":548,"column":13,"nodeType":"604","messageId":"617","endLine":548,"endColumn":22,"fix":"828"},{"ruleId":"615","severity":1,"message":"801","line":554,"column":13,"nodeType":"604","messageId":"617","endLine":554,"endColumn":20,"fix":"829"},{"ruleId":"615","severity":1,"message":"803","line":555,"column":22,"nodeType":"604","messageId":"617","endLine":555,"endColumn":36,"fix":"830"},{"ruleId":"615","severity":1,"message":"815","line":556,"column":13,"nodeType":"604","messageId":"617","endLine":556,"endColumn":18,"fix":"831"},{"ruleId":"615","severity":1,"message":"805","line":557,"column":16,"nodeType":"604","messageId":"617","endLine":557,"endColumn":31,"fix":"832"},{"ruleId":"615","severity":1,"message":"812","line":567,"column":13,"nodeType":"604","messageId":"617","endLine":567,"endColumn":22},{"ruleId":"646","severity":1,"message":"647","line":569,"column":23,"nodeType":"648","messageId":"649","endLine":569,"endColumn":25},{"ruleId":"646","severity":1,"message":"647","line":570,"column":45,"nodeType":"648","messageId":"649","endLine":570,"endColumn":47},{"ruleId":"615","severity":1,"message":"833","line":623,"column":15,"nodeType":"604","messageId":"617","endLine":623,"endColumn":24,"fix":"834"},{"ruleId":"615","severity":1,"message":"835","line":623,"column":26,"nodeType":"604","messageId":"617","endLine":623,"endColumn":32,"fix":"836"},{"ruleId":"615","severity":1,"message":"837","line":623,"column":34,"nodeType":"604","messageId":"617","endLine":623,"endColumn":41,"fix":"838"},{"ruleId":"669","severity":2,"message":"822","line":641,"column":45,"nodeType":"604","messageId":"671","endLine":641,"endColumn":49},{"ruleId":"646","severity":1,"message":"729","line":744,"column":31,"nodeType":"648","messageId":"649","endLine":744,"endColumn":33},{"ruleId":"691","severity":2,"message":"786","line":3,"column":51,"nodeType":"693","messageId":"694","endLine":3,"endColumn":66,"fix":"839"},{"ruleId":"650","severity":2,"message":"651","line":273,"column":21,"nodeType":"652","messageId":"649","endLine":273,"endColumn":29},{"ruleId":"646","severity":1,"message":"647","line":332,"column":39,"nodeType":"648","messageId":"649","endLine":332,"endColumn":41},{"ruleId":"643","severity":2,"message":"644","line":344,"column":35,"nodeType":"604","messageId":"645","endLine":344,"endColumn":42},{"ruleId":"792","severity":2,"message":"793","line":349,"column":33,"nodeType":"794","messageId":"795","endLine":353,"endColumn":34},{"ruleId":"840","severity":2,"message":"841","line":350,"column":67,"nodeType":"604","messageId":"842","endLine":350,"endColumn":76},{"ruleId":"646","severity":1,"message":"647","line":359,"column":48,"nodeType":"648","messageId":"649","endLine":359,"endColumn":50},{"ruleId":"840","severity":2,"message":"841","line":362,"column":41,"nodeType":"604","messageId":"842","endLine":362,"endColumn":50},{"ruleId":"792","severity":2,"message":"793","line":394,"column":37,"nodeType":"794","messageId":"795","endLine":403,"endColumn":38},{"ruleId":"650","severity":2,"message":"651","line":413,"column":29,"nodeType":"652","messageId":"649","endLine":413,"endColumn":38},{"ruleId":"650","severity":2,"message":"651","line":425,"column":41,"nodeType":"652","messageId":"649","endLine":425,"endColumn":50},{"ruleId":"615","severity":1,"message":"796","line":445,"column":23,"nodeType":"604","messageId":"617","endLine":445,"endColumn":35,"fix":"843"},{"ruleId":"660","severity":2,"message":"661","line":477,"column":5,"nodeType":"727","messageId":"663","endLine":477,"endColumn":22},{"ruleId":"660","severity":2,"message":"661","line":488,"column":5,"nodeType":"727","messageId":"663","endLine":488,"endColumn":25},{"ruleId":"660","severity":2,"message":"844","line":488,"column":19,"nodeType":"604","messageId":"845","endLine":488,"endColumn":24},{"ruleId":"660","severity":2,"message":"661","line":494,"column":5,"nodeType":"727","messageId":"663","endLine":494,"endColumn":23},{"ruleId":"660","severity":2,"message":"846","line":499,"column":22,"nodeType":"604","messageId":"845","endLine":499,"endColumn":30},{"ruleId":"660","severity":2,"message":"661","line":504,"column":5,"nodeType":"727","messageId":"663","endLine":504,"endColumn":52},{"ruleId":"660","severity":2,"message":"661","line":510,"column":5,"nodeType":"727","messageId":"663","endLine":510,"endColumn":100},{"ruleId":"615","severity":1,"message":"796","line":511,"column":15,"nodeType":"604","messageId":"617","endLine":511,"endColumn":27,"fix":"847"},{"ruleId":"615","severity":1,"message":"799","line":512,"column":13,"nodeType":"604","messageId":"617","endLine":512,"endColumn":22,"fix":"848"},{"ruleId":"615","severity":1,"message":"801","line":515,"column":13,"nodeType":"604","messageId":"617","endLine":515,"endColumn":20,"fix":"849"},{"ruleId":"615","severity":1,"message":"803","line":516,"column":22,"nodeType":"604","messageId":"617","endLine":516,"endColumn":36,"fix":"850"},{"ruleId":"615","severity":1,"message":"805","line":517,"column":16,"nodeType":"604","messageId":"617","endLine":517,"endColumn":31,"fix":"851"},{"ruleId":"646","severity":1,"message":"647","line":524,"column":38,"nodeType":"648","messageId":"649","endLine":524,"endColumn":40},{"ruleId":"660","severity":2,"message":"661","line":530,"column":5,"nodeType":"727","messageId":"663","endLine":530,"endColumn":39},{"ruleId":"615","severity":1,"message":"796","line":531,"column":15,"nodeType":"604","messageId":"617","endLine":531,"endColumn":27,"fix":"852"},{"ruleId":"615","severity":1,"message":"799","line":532,"column":13,"nodeType":"604","messageId":"617","endLine":532,"endColumn":22,"fix":"853"},{"ruleId":"615","severity":1,"message":"801","line":534,"column":13,"nodeType":"604","messageId":"617","endLine":534,"endColumn":20,"fix":"854"},{"ruleId":"615","severity":1,"message":"803","line":535,"column":22,"nodeType":"604","messageId":"617","endLine":535,"endColumn":36,"fix":"855"},{"ruleId":"615","severity":1,"message":"805","line":536,"column":16,"nodeType":"604","messageId":"617","endLine":536,"endColumn":31,"fix":"856"},{"ruleId":"646","severity":1,"message":"647","line":539,"column":23,"nodeType":"648","messageId":"649","endLine":539,"endColumn":25},{"ruleId":"646","severity":1,"message":"647","line":540,"column":45,"nodeType":"648","messageId":"649","endLine":540,"endColumn":47},{"ruleId":"615","severity":1,"message":"812","line":550,"column":13,"nodeType":"604","messageId":"617","endLine":550,"endColumn":22,"fix":"857"},{"ruleId":"660","severity":2,"message":"661","line":555,"column":5,"nodeType":"727","messageId":"663","endLine":555,"endColumn":18},{"ruleId":"615","severity":1,"message":"796","line":556,"column":15,"nodeType":"604","messageId":"617","endLine":556,"endColumn":27,"fix":"858"},{"ruleId":"660","severity":2,"message":"661","line":559,"column":5,"nodeType":"727","messageId":"663","endLine":559,"endColumn":51},{"ruleId":"660","severity":2,"message":"661","line":565,"column":5,"nodeType":"727","messageId":"663","endLine":565,"endColumn":46},{"ruleId":"615","severity":1,"message":"815","line":568,"column":13,"nodeType":"604","messageId":"617","endLine":568,"endColumn":18,"fix":"859"},{"ruleId":"650","severity":2,"message":"651","line":575,"column":21,"nodeType":"652","messageId":"649","endLine":575,"endColumn":30},{"ruleId":"615","severity":1,"message":"817","line":597,"column":13,"nodeType":"604","messageId":"617","endLine":597,"endColumn":27,"fix":"860"},{"ruleId":"615","severity":1,"message":"819","line":604,"column":13,"nodeType":"604","messageId":"617","endLine":604,"endColumn":19,"fix":"861"},{"ruleId":"660","severity":2,"message":"661","line":609,"column":5,"nodeType":"727","messageId":"663","endLine":609,"endColumn":53},{"ruleId":"660","severity":2,"message":"661","line":624,"column":5,"nodeType":"727","messageId":"663","endLine":624,"endColumn":52},{"ruleId":"615","severity":1,"message":"819","line":625,"column":13,"nodeType":"604","messageId":"617","endLine":625,"endColumn":19,"fix":"862"},{"ruleId":"615","severity":1,"message":"796","line":629,"column":15,"nodeType":"604","messageId":"617","endLine":629,"endColumn":27,"fix":"863"},{"ruleId":"615","severity":1,"message":"824","line":630,"column":13,"nodeType":"604","messageId":"617","endLine":630,"endColumn":25,"fix":"864"},{"ruleId":"615","severity":1,"message":"826","line":631,"column":13,"nodeType":"604","messageId":"617","endLine":631,"endColumn":23,"fix":"865"},{"ruleId":"615","severity":1,"message":"799","line":633,"column":13,"nodeType":"604","messageId":"617","endLine":633,"endColumn":22,"fix":"866"},{"ruleId":"615","severity":1,"message":"801","line":639,"column":13,"nodeType":"604","messageId":"617","endLine":639,"endColumn":20,"fix":"867"},{"ruleId":"615","severity":1,"message":"803","line":640,"column":22,"nodeType":"604","messageId":"617","endLine":640,"endColumn":36,"fix":"868"},{"ruleId":"615","severity":1,"message":"815","line":641,"column":13,"nodeType":"604","messageId":"617","endLine":641,"endColumn":18,"fix":"869"},{"ruleId":"615","severity":1,"message":"805","line":642,"column":16,"nodeType":"604","messageId":"617","endLine":642,"endColumn":31,"fix":"870"},{"ruleId":"615","severity":1,"message":"812","line":652,"column":13,"nodeType":"604","messageId":"617","endLine":652,"endColumn":22},{"ruleId":"646","severity":1,"message":"647","line":654,"column":23,"nodeType":"648","messageId":"649","endLine":654,"endColumn":25},{"ruleId":"646","severity":1,"message":"647","line":655,"column":45,"nodeType":"648","messageId":"649","endLine":655,"endColumn":47},{"ruleId":"615","severity":1,"message":"833","line":708,"column":15,"nodeType":"604","messageId":"617","endLine":708,"endColumn":24,"fix":"871"},{"ruleId":"615","severity":1,"message":"835","line":708,"column":26,"nodeType":"604","messageId":"617","endLine":708,"endColumn":32,"fix":"872"},{"ruleId":"615","severity":1,"message":"837","line":708,"column":34,"nodeType":"604","messageId":"617","endLine":708,"endColumn":41,"fix":"873"},{"ruleId":"646","severity":1,"message":"729","line":830,"column":31,"nodeType":"648","messageId":"649","endLine":830,"endColumn":33},{"ruleId":"615","severity":1,"message":"874","line":50,"column":9,"nodeType":"604","messageId":"617","endLine":50,"endColumn":24,"fix":"875"},{"ruleId":"615","severity":1,"message":"876","line":58,"column":9,"nodeType":"604","messageId":"617","endLine":58,"endColumn":16,"fix":"877"},{"ruleId":"615","severity":1,"message":"878","line":81,"column":5,"nodeType":"604","messageId":"617","endLine":81,"endColumn":13},{"ruleId":"879","severity":2,"message":"880","line":3,"column":15,"nodeType":"614","messageId":"881","endLine":3,"endColumn":16,"fix":"882"},{"ruleId":"879","severity":2,"message":"880","line":3,"column":40,"nodeType":"614","messageId":"881","endLine":3,"endColumn":41,"fix":"883"},{"ruleId":"884","severity":2,"message":"885","line":3,"column":72,"nodeType":"614","messageId":"649","endLine":3,"endColumn":77,"fix":"886"},{"ruleId":"884","severity":2,"message":"885","line":3,"column":84,"nodeType":"614","messageId":"649","endLine":3,"endColumn":89,"fix":"887"},{"ruleId":"884","severity":2,"message":"885","line":3,"column":96,"nodeType":"614","messageId":"649","endLine":3,"endColumn":101,"fix":"888"},{"ruleId":"884","severity":2,"message":"885","line":3,"column":108,"nodeType":"614","messageId":"649","endLine":3,"endColumn":113,"fix":"889"},{"ruleId":"890","severity":2,"message":"891","line":3,"column":118,"nodeType":"614","messageId":"892","endLine":3,"endColumn":119,"fix":"893"},{"ruleId":"884","severity":2,"message":"894","line":3,"column":132,"nodeType":"614","messageId":"649","endLine":3,"endColumn":135,"fix":"895"},{"ruleId":"623","severity":2,"message":"624","line":45,"column":15,"nodeType":"625","messageId":"626","endLine":45,"endColumn":29},{"ruleId":"896","severity":2,"message":"897","line":20,"column":29,"nodeType":"898","messageId":"899","endLine":20,"endColumn":42},{"ruleId":"615","severity":1,"message":"767","line":30,"column":13,"nodeType":"604","messageId":"617","endLine":30,"endColumn":19,"fix":"900"},{"ruleId":"615","severity":1,"message":"901","line":39,"column":9,"nodeType":"604","messageId":"617","endLine":39,"endColumn":13,"fix":"902"},{"ruleId":"646","severity":1,"message":"647","line":93,"column":23,"nodeType":"648","messageId":"649","endLine":93,"endColumn":25},{"ruleId":"646","severity":1,"message":"647","line":94,"column":23,"nodeType":"648","messageId":"649","endLine":94,"endColumn":25},{"ruleId":"646","severity":1,"message":"647","line":95,"column":23,"nodeType":"648","messageId":"649","endLine":95,"endColumn":25},{"ruleId":"903","severity":2,"message":"904","line":5,"column":5,"nodeType":"648","messageId":"649","endLine":5,"endColumn":12},{"ruleId":"612","severity":2,"message":"744","line":8,"column":31,"nodeType":"614","endLine":8,"endColumn":56},{"ruleId":"612","severity":2,"message":"905","line":9,"column":20,"nodeType":"614","endLine":9,"endColumn":34},{"ruleId":"612","severity":2,"message":"906","line":10,"column":32,"nodeType":"614","endLine":10,"endColumn":58},{"ruleId":"612","severity":2,"message":"907","line":13,"column":27,"nodeType":"614","endLine":13,"endColumn":45},{"ruleId":"615","severity":1,"message":"908","line":165,"column":5,"nodeType":"604","messageId":"617","endLine":165,"endColumn":12,"fix":"909"},{"ruleId":"646","severity":1,"message":"647","line":218,"column":24,"nodeType":"648","messageId":"649","endLine":218,"endColumn":26,"fix":"910"},{"ruleId":"646","severity":1,"message":"647","line":219,"column":22,"nodeType":"648","messageId":"649","endLine":219,"endColumn":24,"fix":"911"},{"ruleId":"615","severity":1,"message":"912","line":228,"column":15,"nodeType":"604","messageId":"617","endLine":228,"endColumn":24,"fix":"913"},{"ruleId":"615","severity":1,"message":"914","line":229,"column":13,"nodeType":"604","messageId":"617","endLine":229,"endColumn":20,"fix":"915"},{"ruleId":"650","severity":2,"message":"651","line":254,"column":18,"nodeType":"652","messageId":"649","endLine":254,"endColumn":27},{"ruleId":"650","severity":2,"message":"651","line":255,"column":39,"nodeType":"652","messageId":"649","endLine":255,"endColumn":48},{"ruleId":"615","severity":1,"message":"916","line":461,"column":13,"nodeType":"604","messageId":"617","endLine":461,"endColumn":19,"fix":"917"},{"ruleId":"615","severity":1,"message":"918","line":461,"column":21,"nodeType":"604","messageId":"617","endLine":461,"endColumn":28,"fix":"919"},{"ruleId":"615","severity":1,"message":"920","line":462,"column":29,"nodeType":"604","messageId":"617","endLine":462,"endColumn":39,"fix":"921"},{"ruleId":"615","severity":1,"message":"922","line":463,"column":21,"nodeType":"604","messageId":"617","endLine":463,"endColumn":26,"fix":"923"},{"ruleId":"615","severity":1,"message":"924","line":467,"column":18,"nodeType":"604","messageId":"617","endLine":467,"endColumn":22,"fix":"925"},{"ruleId":"615","severity":1,"message":"926","line":469,"column":14,"nodeType":"604","messageId":"617","endLine":469,"endColumn":27,"fix":"927"},{"ruleId":"615","severity":1,"message":"912","line":475,"column":16,"nodeType":"604","messageId":"617","endLine":475,"endColumn":25,"fix":"928"},{"ruleId":"615","severity":1,"message":"914","line":477,"column":13,"nodeType":"604","messageId":"617","endLine":477,"endColumn":20,"fix":"929"},{"ruleId":"731","severity":2,"message":"930","line":515,"column":16,"nodeType":"727","messageId":"649","endLine":515,"endColumn":18},{"ruleId":"669","severity":2,"message":"822","line":672,"column":22,"nodeType":"604","messageId":"671","endLine":672,"endColumn":26},{"ruleId":"650","severity":2,"message":"651","line":680,"column":22,"nodeType":"652","messageId":"649","endLine":680,"endColumn":31},{"ruleId":"650","severity":2,"message":"651","line":688,"column":13,"nodeType":"652","messageId":"649","endLine":688,"endColumn":22},{"ruleId":"646","severity":1,"message":"931","line":692,"column":61,"nodeType":"648","messageId":"649","endLine":692,"endColumn":64},{"ruleId":"646","severity":1,"message":"931","line":693,"column":39,"nodeType":"648","messageId":"649","endLine":693,"endColumn":42},{"ruleId":"650","severity":2,"message":"651","line":694,"column":13,"nodeType":"652","messageId":"649","endLine":694,"endColumn":22},{"ruleId":"650","severity":2,"message":"651","line":742,"column":22,"nodeType":"652","messageId":"649","endLine":742,"endColumn":31},{"ruleId":"646","severity":1,"message":"647","line":761,"column":18,"nodeType":"648","messageId":"649","endLine":761,"endColumn":20,"fix":"932"},{"ruleId":"650","severity":2,"message":"651","line":830,"column":25,"nodeType":"652","messageId":"649","endLine":830,"endColumn":34},{"ruleId":"615","severity":1,"message":"933","line":838,"column":9,"nodeType":"604","messageId":"617","endLine":838,"endColumn":25,"fix":"934"},{"ruleId":"623","severity":2,"message":"624","line":844,"column":17,"nodeType":"625","messageId":"626","endLine":844,"endColumn":31},{"ruleId":"623","severity":2,"message":"624","line":853,"column":17,"nodeType":"625","messageId":"626","endLine":853,"endColumn":31},{"ruleId":"623","severity":2,"message":"624","line":862,"column":17,"nodeType":"625","messageId":"626","endLine":862,"endColumn":31},{"ruleId":"669","severity":2,"message":"822","line":889,"column":16,"nodeType":"604","messageId":"671","endLine":889,"endColumn":20},{"ruleId":"669","severity":2,"message":"822","line":982,"column":31,"nodeType":"604","messageId":"671","endLine":982,"endColumn":35},{"ruleId":"650","severity":2,"message":"651","line":1031,"column":13,"nodeType":"652","messageId":"649","endLine":1031,"endColumn":22},{"ruleId":"669","severity":2,"message":"822","line":1055,"column":22,"nodeType":"604","messageId":"671","endLine":1055,"endColumn":26},{"ruleId":"646","severity":1,"message":"647","line":1099,"column":18,"nodeType":"648","messageId":"649","endLine":1099,"endColumn":20,"fix":"935"},{"ruleId":"669","severity":2,"message":"936","line":1147,"column":29,"nodeType":"604","messageId":"671","endLine":1147,"endColumn":36},{"ruleId":"646","severity":1,"message":"730","line":1237,"column":33,"nodeType":"648","messageId":"649","endLine":1237,"endColumn":36},{"ruleId":"615","severity":1,"message":"937","line":1288,"column":13,"nodeType":"604","messageId":"617","endLine":1288,"endColumn":23,"fix":"938"},{"ruleId":"669","severity":2,"message":"822","line":1289,"column":22,"nodeType":"604","messageId":"671","endLine":1289,"endColumn":26},{"ruleId":"650","severity":2,"message":"651","line":1323,"column":52,"nodeType":"652","messageId":"649","endLine":1323,"endColumn":61},{"ruleId":"669","severity":2,"message":"822","line":1341,"column":33,"nodeType":"604","messageId":"671","endLine":1341,"endColumn":37},"no-restricted-globals","Unexpected use of 'require'.","Identifier","defaultMessage","import/order","`rollup-plugin-postcss` import should occur before import of `sass`","ImportDeclaration",{"range":"939","text":"940"},"`@poshplum/utils/browser` import should occur before import of `./Reactor`",{"range":"941","text":"942"},"node/no-missing-import","\"@poshplum/utils/browser\" is not found.","Literal","prefer-const","'slot' is never reassigned. Use 'const' instead.","useConst",{"range":"943","text":"944"},{"range":"945","text":"946"},{"range":"947","text":"948"},"'slots' is never reassigned. Use 'const' instead.",{"range":"949","text":"950"},"no-prototype-builtins","Do not access Object.prototype method 'hasOwnProperty' from target object.","CallExpression","prototypeBuildIn","'slotName' is never reassigned. Use 'const' instead.",{"range":"951","text":"952"},"'foundSlot' is never reassigned. Use 'const' instead.",{"range":"953","text":"954"},"'defaultSlot' is never reassigned. Use 'const' instead.",{"range":"955","text":"956"},"'defaultSlotName' is never reassigned. Use 'const' instead.",{"range":"957","text":"958"},"'childName' is never reassigned. Use 'const' instead.",{"range":"959","text":"960"},"Do not access Object.prototype method 'isPrototypeOf' from target object.",{"range":"961","text":"962"},"'foundDisplayName' is never reassigned. Use 'const' instead.",{"range":"963","text":"964"},{"range":"965","text":"966"},{"range":"967","text":"968"},"@typescript-eslint/no-this-alias","Unexpected aliasing of 'this' to local variable.","thisAssignment","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-debugger","Unexpected 'debugger' statement.","DebuggerStatement",["969"],["970"],["971"],["972"],["973"],["974"],["975"],"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","ArrowFunctionExpression","missingReturnType","Object pattern argument should be typed.","ObjectPattern","missingArgTypeUnnamed","`@poshplum/utils/browser` import should occur before import of `../Reactor`",{"range":"976","text":"977"},"no-undef","'window' is not defined.","undef","'probeEvent' is never reassigned. Use 'const' instead.",{"range":"978","text":"979"},"no-dupe-class-members","Duplicate name 'updateOnFocusChange'.","MethodDefinition","'requestAnimationFrame' is not defined.","Duplicate name 'findFocusedShortcuts'.","'document' is not defined.","'handlers' is never reassigned. Use 'const' instead.",{"range":"980","text":"981"},"'current' is never reassigned. Use 'const' instead.",{"range":"982","text":"981"},"'focused' is never reassigned. Use 'const' instead.",{"range":"983","text":"981"},"Duplicate name 'registerKeyHandler'.","'triggerDescription' is not defined.","Duplicate name 'removeKeyHandler'.","'thisKeyBinding' is never reassigned. Use 'const' instead.",{"range":"984","text":"985"},"sort-imports","Member 'Actor' of the import declaration should be sorted alphabetically.","ImportSpecifier","sortMembersAlphabetically",{"range":"986","text":"987"},"'notices' is never reassigned. Use 'const' instead.",{"range":"988","text":"989"},"'hold' is never reassigned. Use 'const' instead.",{"range":"990","text":"989"},"'tooltip' is never reassigned. Use 'const' instead.",{"range":"991","text":"992"},"'Title' is never reassigned. Use 'const' instead.",{"range":"993","text":"994"},"'Icon' is never reassigned. Use 'const' instead.",{"range":"995","text":"996"},"'Label' is never reassigned. Use 'const' instead.",{"range":"997","text":"998"},"'Body' is never reassigned. Use 'const' instead.",{"range":"999","text":"1000"},{"range":"1001","text":"1002"},{"range":"1003","text":"1002"},"'HeaderRight' is never reassigned. Use 'const' instead.",{"range":"1004","text":"1002"},{"range":"1005","text":"1002"},"'Footer' is never reassigned. Use 'const' instead.",{"range":"1006","text":"1002"},{"range":"1007","text":"1002"},"'chip' is never reassigned. Use 'const' instead.",{"range":"1008","text":"1009"},"'error' is never reassigned. Use 'const' instead.",{"range":"1010","text":"1011"},"'success' is never reassigned. Use 'const' instead.",{"range":"1012","text":"1013"},"'warning' is never reassigned. Use 'const' instead.",{"range":"1014","text":"1013"},{"range":"1015","text":"1013"},"FunctionExpression","'navigator' is not defined.","Expected '!==' and instead saw '!='.","Expected '==' and instead saw '==='.","@typescript-eslint/no-empty-function","Unexpected empty function.","'PlatformSubtleCrypto' is never reassigned. Use 'const' instead.",{"range":"1016","text":"1017"},"'self' is not defined.","node/no-unsupported-features/node-builtins","The 'TextEncoder' is not supported until Node.js 11.0.0. The configured version range is '>=8.0.0'.","unsupported","'localStorage' is not defined.",{"range":"1018","text":"1019"},"import/no-nodejs-modules","Do not import Node.js builtin module \"child_process\"","ExportAllDeclaration","\"@platform/child_process\" is not found.","no-extra-boolean-cast","Redundant double negation.","UnaryExpression","unexpectedNegation",{"range":"1020","text":"1021"},"regexp/no-useless-character-class","Unexpected character class with one character. Can remove brackets.",{"range":"1022","text":"1023"},"Unexpected use of '__dirname'.","Do not import Node.js builtin module \"os\"","The 'os.getPriority' is not supported until Node.js 10.10.0. The configured version range is '>=8.0.0'.","The 'os.setPriority' is not supported until Node.js 10.10.0. The configured version range is '>=8.0.0'.","Do not import Node.js builtin module \"path\"","`path` import should occur before import of `rollup-plugin-dts`",{"range":"1024","text":"1025"},"\"@platform/TextEncoder\" is not found.","\"@platform/SubtleCrypto\" is not found.","'plainBuffer' is never reassigned. Use 'const' instead.",{"range":"1026","text":"1027"},"'signature' is never reassigned. Use 'const' instead.",{"range":"1028","text":"1029"},{"range":"1030","text":"1031"},"'result' is never reassigned. Use 'const' instead.",{"range":"1032","text":"1033"},"'jwk' is never reassigned. Use 'const' instead.",{"range":"1034","text":"1035"},{"range":"1036","text":"1027"},{"range":"1037","text":"1038"},"'key' is never reassigned. Use 'const' instead.",{"range":"1039","text":"1040"},"'keyJwk' is never reassigned. Use 'const' instead.",{"range":"1041","text":"1042"},"'e' is never reassigned. Use 'const' instead.",{"range":"1043","text":"1044"},"'kty' is never reassigned. Use 'const' instead.",{"range":"1045","text":"1044"},"'n' is never reassigned. Use 'const' instead.",{"range":"1046","text":"1044"},"'hash' is never reassigned. Use 'const' instead.",{"range":"1047","text":"1048"},{"range":"1049","text":"1050"},"Member 'ZonedStackTrace' of the import declaration should be sorted alphabetically.",{"range":"1051","text":"1052"},"no-unreachable","Unreachable code.","ReturnStatement","unreachableCode","no-useless-catch","Unnecessary try/catch wrapper.","TryStatement","unnecessaryCatch","'currentState' is never reassigned. Use 'const' instead.",{"range":"1053","text":"1054"},{"range":"1055","text":"1054"},"'thisState' is never reassigned. Use 'const' instead.",{"range":"1056","text":"1057"},"'onEntry' is never reassigned. Use 'const' instead.",{"range":"1058","text":"1059"},"'isDefaultState' is never reassigned. Use 'const' instead.",{"range":"1060","text":"1059"},"'goodTransitions' is never reassigned. Use 'const' instead.",{"range":"1061","text":"1059"},{"range":"1062","text":"1054"},{"range":"1063","text":"1057"},{"range":"1064","text":"1059"},{"range":"1065","text":"1059"},{"range":"1066","text":"1059"},"'nextState' is never reassigned. Use 'const' instead.",{"range":"1067","text":"1068"},{"range":"1069","text":"1054"},"'label' is never reassigned. Use 'const' instead.",{"range":"1070","text":"1071"},"'transitionZone' is never reassigned. Use 'const' instead.",{"range":"1072","text":"1073"},"'logger' is never reassigned. Use 'const' instead.",{"range":"1074","text":"1075"},{"range":"1076","text":"1077"},"'Zone' is not defined.",{"range":"1078","text":"1054"},"'machineLabel' is never reassigned. Use 'const' instead.",{"range":"1079","text":"1080"},"'shortLabel' is never reassigned. Use 'const' instead.",{"range":"1081","text":"1082"},{"range":"1083","text":"1084"},{"range":"1085","text":"1086"},{"range":"1087","text":"1086"},{"range":"1088","text":"1086"},{"range":"1089","text":"1086"},"'predicate' is never reassigned. Use 'const' instead.",{"range":"1090","text":"1091"},"'effect' is never reassigned. Use 'const' instead.",{"range":"1092","text":"1091"},"'reEntry' is never reassigned. Use 'const' instead.",{"range":"1093","text":"1091"},{"range":"1094","text":"1052"},"prefer-rest-params","Use the rest parameters instead of 'arguments'.","preferRestParams",{"range":"1095","text":"1054"},"Argument 'state' should be typed.","missingArgType","Argument 'newState' should be typed.",{"range":"1096","text":"1054"},{"range":"1097","text":"1057"},{"range":"1098","text":"1059"},{"range":"1099","text":"1059"},{"range":"1100","text":"1059"},{"range":"1101","text":"1054"},{"range":"1102","text":"1057"},{"range":"1103","text":"1059"},{"range":"1104","text":"1059"},{"range":"1105","text":"1059"},{"range":"1106","text":"1068"},{"range":"1107","text":"1054"},{"range":"1108","text":"1071"},{"range":"1109","text":"1073"},{"range":"1110","text":"1075"},{"range":"1111","text":"1077"},{"range":"1112","text":"1054"},{"range":"1113","text":"1080"},{"range":"1114","text":"1082"},{"range":"1115","text":"1084"},{"range":"1116","text":"1086"},{"range":"1117","text":"1086"},{"range":"1118","text":"1086"},{"range":"1119","text":"1086"},{"range":"1120","text":"1091"},{"range":"1121","text":"1091"},{"range":"1122","text":"1091"},"'anotherCallToMe' is never reassigned. Use 'const' instead.",{"range":"1123","text":"1124"},"'myGhost' is never reassigned. Use 'const' instead.",{"range":"1125","text":"1126"},"'resolved' is never reassigned. Use 'const' instead.","regexp/no-useless-escape","Unnecessary escape character: \\[.","unnecessary",{"range":"1127","text":"1128"},{"range":"1129","text":"1128"},"regexp/prefer-d","Unexpected character class '[0-9]'. Use '\\d' instead.",{"range":"1130","text":"1131"},{"range":"1132","text":"1131"},{"range":"1133","text":"1131"},{"range":"1134","text":"1131"},"regexp/strict","Unescaped source character ']'.","unescapedSourceCharacter",{"range":"1135","text":"1136"},"Unexpected character class range '0-9'. Use '\\d' instead.",{"range":"1137","text":"1131"},"no-self-assign","'failure.stack' is assigned to itself.","MemberExpression","selfAssignment",{"range":"1138","text":"1139"},"'func' is never reassigned. Use 'const' instead.",{"range":"1140","text":"1141"},"no-constant-condition","Unexpected constant condition.","\"@platform/os\" is not found.","\"@platform/logDestination\" is not found.","\"@platform/stdout\" is not found.","'logDest' is never reassigned. Use 'const' instead.",{"range":"1142","text":"1143"},{"range":"1144","text":"1145"},{"range":"1146","text":"1145"},"'chindings' is never reassigned. Use 'const' instead.",{"range":"1147","text":"1148"},"'objects' is never reassigned. Use 'const' instead.",{"range":"1149","text":"1150"},"'detail' is never reassigned. Use 'const' instead.",{"range":"1151","text":"1152"},"'summary' is never reassigned. Use 'const' instead.",{"range":"1153","text":"1152"},"'cmOverride' is never reassigned. Use 'const' instead.",{"range":"1154","text":"1152"},"'space' is never reassigned. Use 'const' instead.",{"range":"1155","text":"1152"},"'rest' is never reassigned. Use 'const' instead.",{"range":"1156","text":"1157"},"'consoleMethod' is never reassigned. Use 'const' instead.",{"range":"1158","text":"1159"},{"range":"1160","text":"1148"},{"range":"1161","text":"1150"},"Unexpected empty method 'noop'.","Expected '!=' and instead saw '!=='.",{"range":"1162","text":"1145"},"'enhancedLogProps' is never reassigned. Use 'const' instead.",{"range":"1163","text":"1164"},{"range":"1165","text":"1145"},"'message' is not defined.","'splitStack' is never reassigned. Use 'const' instead.",{"range":"1166","text":"1167"},[186,261],"import postcss from \"rollup-plugin-postcss\";\nconst sass = require(\"sass\");\n",[222,311],"import { autobind } from \"@poshplum/utils/browser\";\nimport { Reactor } from \"./Reactor\";\n",[656,688],"const slot = this.namedSlot(name);",[2663,2807],"const slot = (componentWithMarkup = ({ children, ...props }) => (\n            <RenderComponent {...props}>{children}</RenderComponent>\n        ));",[3796,3836],"const slot = ({ children }) => [children];",[4883,4923],"const slots = this.constructor.getSlots();",[5193,5464],"const slotName =\n                    slot.slotName ||\n                    slot.constructor.wrappedName ||\n                    slot.displayName ||\n                    slot.constructor.displayName ||\n                    slot.name ||\n                    slot.constructor.name;",[5543,5586],"const foundSlot = this.constructor[slotName];",[6301,6365],"const defaultSlot = find(slots, (slotType) => slotType.isDefault);",[6374,6469],"const defaultSlotName =\n            defaultSlot && (defaultSlot.displayName || defaultSlot.name);",[7806,8085],"const childName =\n                            (child.type &&\n                                // child.type.slotName ||\n                                (child.type.wrappedName ||\n                                    child.type.displayName)) ||\n                            child.type;",[8535,8581],"const foundSlot = foundName && slots[foundName];",[8594,8661],"const foundDisplayName = foundSlot && slotToSlotNames.get(foundSlot);",[10218,10245],"const foundSlot = slots[key];",[11320,11414],"const childName =\n                            (item.type && item.type.displayName) || item.type;",{"kind":"1168","justification":"1169"},{"kind":"1168","justification":"1169"},{"kind":"1168","justification":"1169"},{"kind":"1168","justification":"1169"},{"kind":"1168","justification":"1169"},{"kind":"1168","justification":"1169"},{"kind":"1168","justification":"1169"},[27,322],"import { autobind } from \"@poshplum/utils/browser\";\nimport { Reactor } from \"../Reactor\";\nimport { Action } from \"../reactor/Action\";\nimport { Mousetrap } from \"../helpers/mousetrap\";\nimport { isInsideDOM, isOutsideDOM } from \"../helpers/isOutsideDOM\";\nimport { Actor } from \"../reactor/Actor\";\n",[1933,2334],"const probeEvent = Reactor.ReactorProbe({\n                single: true,\n                // attach to the first found reactor\n                onReactor(reactor) {\n                    if (targetNode) {\n                        throw new Error(\"this shouldn't happen\");\n                    }\n                    targetNode = reactor.el;\n                    return reactor;\n                },\n            });",[3278,3323],"const { handlers, current, focused } = binding;",[3278,3323],[3278,3323],[12187,12259],"const thisKeyBinding = this.bindings.get(this.shortcutToString(shortcut));",[125,149],"Action, Actor, Subscribe",[3158,3209],"const { notices = [], hold = \"\" } = this.state || {};",[3158,3209],[3218,3276],"const tooltip = (hold && { \"data-tooltip\": \"✋ 🖱️\" }) || {};",[104,330],"const Title = Layout.defaultSlot(\"Title\").withMarkup(({className=\"\", children, ...props}) => {\n    return <span key=\"title\" className={`${className}`} {...props}>\n        <h6>\n            {children}\n        </h6>\n    </span>\n});",[387,606],"const Icon = Layout.namedSlot(\"Icon\").withMarkup(({className=\"\", icon, children, ...props}) => {\n    return <div key=\"icon\" className={`avatar avatar-sm ${className}`} {...props}>\n        {icon || children}\n    </div>\n});",[608,836],"const Label = Layout.namedSlot(\"Label\").withMarkup(({as:As=\"div\", className=\"\", icon, children, ...props}) => {\n    return <As key=\"label\" className={`float-right ${className}`} {...props}>\n        {icon || children}\n    </As>\n});",[838,1040],"const Body = Layout.namedSlot(\"Body\").withMarkup(({as:As=\"div\", className=\"\", children, ...props}) => {\n    return <As className={`footnote ml-2 ${className}`} {...props}>\n        {children}\n    </As>\n});",[1573,1638],"const {Title, Icon, HeaderRight, Body, Footer, Label} = this.slots;",[1573,1638],[1573,1638],[1573,1638],[1573,1638],[1573,1638],[2254,2846],"const chip = <As {...wrapperProps} onClick={onClick} className={`chip-wrapper d-inline-block ${widthClass} ${wrapperClassName} ${active ? \"active\" : \"\"}`}>\n            {Icon}\n            <As {...otherProps} tabIndex={tabIndex} className={`chip ${multiLineClass} ${className} ${active ? \"active\" : \"\"}`}>\n                {Label}\n                {Title}\n                {link && Title && showScreaderLink}\n\n                {multiLine && Body && <div className=\"flex-break-line\"></div>}\n                {Body}\n\n                {link && !Title && showScreaderLink}\n            </As>\n        </As >;",[560,587],"const { error } = this.props;",[559,604],"const { success, warning, error } = this.props;",[559,604],[559,604],[8,66],"const PlatformSubtleCrypto = (self || window).crypto.subtle;",[47,81],"const PlatformSubtleCrypto = subtle;",[671,710],"parseInt(localEnv(\"SKIP_DB_LOGGING\"))",[1186,1189],"s",[0,285],"import { join } from \"path\";\nimport dts from \"rollup-plugin-dts\";\nimport typescript from \"rollup-plugin-ts\";\nimport commonjs from \"@rollup/plugin-commonjs\";\nimport replace from \"@rollup/plugin-replace\";\n\n// not needed for browser\nimport externals from \"rollup-plugin-node-externals\";\n\n",[413,482],"const plainBuffer = new PlatformTextEncoder(\"utf-8\").encode(plainText);",[491,718],"const signature = await PlatformSubtleCrypto.sign(\n            {\n                name: \"RSA-PSS\",\n                saltLength: 128, //the length of the salt\n            },\n            privateKey,\n            plainBuffer\n        );",[955,1007],"const signature = this.hexToArrayBuffer(hexSignature);",[1232,1291],"const result = await PlatformSubtleCrypto.digest(algo, data);",[1508,1540],"const jwk = JSON.parse(jwkString);",[2968,3037],[3046,3224],"const result = await PlatformSubtleCrypto.verify(\n            { name: \"RSA-PSS\", saltLength: 128 },\n            publicKey,\n            signature,\n            plainBuffer\n        );",[3918,3957],"const key = await this.generateKey(bits);",[4493,4534],"const keyJwk = await this.toJwk(publicKey);",[4637,4664],"const { e, kty, n } = keyJwk;",[4637,4664],[4637,4664],[4782,4840],"const hash = await this.hash(JSON.stringify({ e, kty, n }));",[4927,5227],"const key = await PlatformSubtleCrypto.generateKey(\n            {\n                name: \"RSA-PSS\",\n                modulusLength: bits,\n                publicExponent: new Uint8Array([1, 0, 1]),\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"sign\", \"verify\"]\n        );",[55,111],"ZonedStackTrace, forkZoneWithContext, forkZoneWithLogger",[16434,16482],"const { currentState = this.defaultState } = this;",[18537,18585],[18594,18664],"const thisState = this.def[currentState] || this.def[this.defaultState];",[18674,18791],"const {\n            onEntry,\n            default: isDefaultState,\n            ...goodTransitions\n        } = thisState;",[18674,18791],[18674,18791],[19196,19244],[19253,19323],[19332,19449],[19332,19449],[19332,19449],[19783,19876],"const nextState =\n            (transition && transition.nextState) || \"‹undefined transition›\";",[19938,19986],[20402,20450],"const label = this.label || this.constructor.name;",[21390,21621],"const transitionZone = forkZoneWithLogger(this.logFacility, logProps, {\n            name: stateMachineName,\n            properties: {\n                location,\n                addContext: transitionContext,\n            },\n        });",[21630,21672],"const logger = transitionZone.get(\"logger\");",[22428,22468],"const logger = Zone.current.get(\"logger\");",[22531,22579],[22588,22643],"const machineLabel = this.label || this.constructor.name;",[22652,22710],"const shortLabel = this.shortLabel || this.constructor.name;",[22720,22759],"const thisState = this.def[currentState];",[22905,23041],"const {\n            onEntry,\n            default: isDefaultState,\n            label,\n            ...goodTransitions\n        } = thisState;",[22905,23041],[22905,23041],[22905,23041],[25348,25404],"const { predicate, effect, reEntry = false } = transition;",[25348,25404],[25348,25404],[52,108],[18835,18883],[21294,21342],[21351,21421],[21431,21548],[21431,21548],[21431,21548],[21962,22010],[22019,22089],[22098,22215],[22098,22215],[22098,22215],[22549,22642],[22704,22752],[23186,23234],[24174,24405],[24414,24456],[25233,25273],[25336,25384],[25393,25448],[25457,25515],[25525,25564],[25710,25846],[25710,25846],[25710,25846],[25710,25846],[28154,28210],[28154,28210],[28154,28210],[2487,2525],"const anotherCallToMe = ctx.aSing[name];",[2825,2859],"const myGhost = ctx.aSing._gh[name];",[73,75],"[",[98,100],[130,135],"\\d",[142,147],[154,159],[166,171],[176,177],"\\]",[190,193],[827,854],"const result = await promise;",[1181,1209],"const func = descriptor.value;",[7479,7510],"const logDest = logDestination();",[8912,8914],"===",[8973,8975],[9288,9313],"const { chindings } = this;",[9322,9365],"const objects = chindings ? [chindings] : [];",[16719,16853],"const { \n            detail, summary,\n            consoleMethod : cmOverride,\n            indent: space=indent,\n         } = extraAttrs;",[16719,16853],[16719,16853],[16719,16853],[16945,16966],"const [...rest] = args;",[16977,17212],"const consoleMethod = cmOverride ? (\n            browserConsoleLogger._methods[cmOverride] =\n                browserConsoleLogger._methods[cmOverride] ||\n                console[cmOverride].bind(console)\n         ) : defaultConsoleMethod",[17223,17248],[17258,17301],[26819,26821],[29541,29614],"const enhancedLogProps = { ...parentLogger.chindings, ...moreLogSettings };",[38680,38682],[45378,45406],"const splitStack = this.stack;","directive",""]